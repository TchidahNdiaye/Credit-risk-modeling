################################################################################
# app.R - Application RShiny RWA Bâle (Standard + IRBA) + Retour4C (3Go+) + DQ
# Auteur : (à compléter)
# Objectif : Modules indépendants:
# 1) Calculateur RWA (Standard + IRBA) Retail/Non-Retail + corrections + graphe
# 2) Chargement Retour4C CSV très volumineux + minuteur + synthèses
# 3) Chargement anomalies_dq.xlsx + extraction contrats + export Excel
# 4) Recalcul RWA corrigé à partir anomalies + comparaison + export Excel
################################################################################

##############################
# 0) Packages + sécurité
##############################
required_pkgs <- c(
  "shiny", "bslib", "data.table", "DT", "ggplot2",
  "readxl", "openxlsx", "shinyjs"
)

missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, FUN.VALUE = logical(1), quietly = TRUE)]
if (length(missing_pkgs) > 0) {
  stop(
    "Packages manquants: ", paste(missing_pkgs, collapse = ", "),
    "\nInstalle-les avec: install.packages(c(", paste0('"', missing_pkgs, '"', collapse = ", "), "))"
  )
}

library(shiny)
library(bslib)
library(data.table)
library(DT)
library(ggplot2)
library(readxl)
library(openxlsx)
library(shinyjs)

options(shiny.maxRequestSize = 10 * 1024^3) # jusqu’à 10Go en upload si besoin

##############################
# 1) Fonctions RWA (Standard + IRBA)
##############################

#---------- 1.1 Standard: RWA = EAD * RW
std_rwa <- function(ead, rw) {
  # ead: numérique (EUR)
  # rw: poids en décimal (ex: 0.75 pour 75%)
  ead <- as.numeric(ead)
  rw  <- as.numeric(rw)
  ead * rw
}

#---------- 1.2 Standard + sûreté (CRM) avec haircuts (version simplifiée)
# Dans Bâle, l'exposition ajustée E* dépend du collatéral et des haircuts.
# Ici : si surete=1, on applique un haircut réglementaire "h" en réduisant EAD
# EAD_adj = EAD * (1 - h). A adapter si vous avez C (collatéral) explicite.
std_rwa_with_collateral <- function(ead, rw, surete = 0, haircut = 0) {
  ead <- as.numeric(ead)
  rw  <- as.numeric(rw)
  surete <- as.integer(surete)
  haircut <- as.numeric(haircut)
  haircut <- pmax(0, pmin(haircut, 1))

  ead_adj <- ifelse(surete == 1, ead * (1 - haircut), ead)
  std_rwa(ead_adj, rw)
}

#---------- 1.3 EAD bilan / hors bilan (standard)
# RWA_B = EAD_B * RW ; RWA_HB = (EAD_HB * CCF) * RW
std_rwa_bilan_hb <- function(ead_b, ead_hb, ccf, rw) {
  ead_b  <- as.numeric(ead_b)
  ead_hb <- as.numeric(ead_hb)
  ccf    <- as.numeric(ccf)
  rw     <- as.numeric(rw)

  rwa_b  <- std_rwa(ead_b, rw)
  rwa_hb <- std_rwa(ead_hb * ccf, rw)
  list(rwa_b = rwa_b, rwa_hb = rwa_hb, rwa_total = rwa_b + rwa_hb)
}

#---------- 1.4 IRBA : fonctions de base (approche IRB type BCBS)
# Implémentation classique:
#   K = LGD * N( (1/sqrt(1-R))*G(PD) + sqrt(R/(1-R))*G(0.999) ) - PD*LGD
#   K_adj (si maturity) = K * (1 + (M - 2.5)*b)/(1 - 1.5*b)
#   RWA = 12.5 * K_adj * EAD * scaling
#
# NB:
# - Retail: souvent pas d'ajustement de maturité (ou M fixé), selon cadre.
# - Les corrélations R diffèrent selon portefeuille.
# - Ici, on propose un paramètre "portfolio" pour choisir R.
#
N <- function(x) stats::pnorm(x)
G <- function(p) stats::qnorm(p)

irb_corr_R <- function(pd, portfolio = c("corporate", "retail_mortgage", "retail_revolving", "retail_other")) {
  portfolio <- match.arg(portfolio)
  pd <- as.numeric(pd)

  # Corrélations typiques (style Bâle II/III). Ajuster si votre doctrine interne Bâle IV diffère.
  if (portfolio == "corporate") {
    # Corporate / Non-retail générique
    R <- 0.12 * (1 - exp(-50 * pd)) / (1 - exp(-50)) +
      0.24 * (1 - (1 - exp(-50 * pd)) / (1 - exp(-50)))
  } else if (portfolio == "retail_mortgage") {
    # Immobilier résidentiel
    R <- 0.15
  } else if (portfolio == "retail_revolving") {
    # Revolving qualifié
    R <- 0.04
  } else {
    # Retail autres
    R <- 0.03 * (1 - exp(-35 * pd)) / (1 - exp(-35)) +
      0.16 * (1 - (1 - exp(-35 * pd)) / (1 - exp(-35)))
  }
  pmax(0, pmin(R, 0.999))
}

irb_maturity_b <- function(pd) {
  pd <- as.numeric(pd)
  (0.11852 - 0.05478 * log(pmax(pd, 1e-10)))^2
}

irb_k <- function(pd, lgd, R) {
  pd  <- as.numeric(pd)
  lgd <- as.numeric(lgd)
  R   <- as.numeric(R)

  # garde-fous
  pd  <- pmax(1e-10, pmin(pd, 1 - 1e-10))
  lgd <- pmax(0, pmin(lgd, 1))
  R   <- pmax(0, pmin(R, 0.999))

  d <- (1 / sqrt(1 - R)) * G(pd) + sqrt(R / (1 - R)) * G(0.999)
  lgd * N(d) - pd * lgd
}

irb_rwa <- function(pd, lgd, ead, M = 2.5, portfolio = "corporate",
                    apply_maturity = TRUE, scaling = 1.06) {
  pd  <- as.numeric(pd)
  lgd <- as.numeric(lgd)
  ead <- as.numeric(ead)
  M   <- as.numeric(M)
  scaling <- as.numeric(scaling)

  R <- irb_corr_R(pd, portfolio = portfolio)
  K <- irb_k(pd, lgd, R)

  if (apply_maturity) {
    b <- irb_maturity_b(pd)
    K_adj <- K * (1 + (M - 2.5) * b) / (1 - 1.5 * b)
  } else {
    K_adj <- K
  }

  12.5 * K_adj * ead * scaling
}

##############################
# 2) Utilitaires Retour4C (gros CSV)
##############################

# Lecture robuste date ASOF_DT
asof_to_date <- function(x) {
  # tente plusieurs formats
  if (inherits(x, "Date")) return(x)
  x <- as.character(x)
  # Essais: yyyy-mm-dd, dd/mm/yyyy, yyyymmdd
  out <- suppressWarnings(as.Date(x, format = "%Y-%m-%d"))
  if (all(is.na(out))) out <- suppressWarnings(as.Date(x, format = "%d/%m/%Y"))
  if (all(is.na(out))) out <- suppressWarnings(as.Date(x, format = "%Y%m%d"))
  out
}

# Synthèses demandées:
# - par GoldenSource
# - par portefeuille bâlois (PRTF)
# Colonnes attendues (à adapter à ton CSV): ASOF_DT, GoldenSource, SG_CONTRACT_ID,
# Encours, EAD, RWA, PRTF, Segment, PRODUCT_ID, SSPRTF ...
#
# IMPORTANT: si tes noms de colonnes diffèrent, ajuste les vecteurs ci-dessous.
RET_COLS_MIN <- c(
  "ASOF_DT", "GoldenSource", "SG_CONTRACT_ID",
  "Encours", "EAD", "RWA",
  "PRTF", "SSPRTF", "Segment", "PRODUCT_ID",
  "SG_CONTR_BCE", "SG_CONTR_3D_ID", "SG_FACILITY_ID", "SG_ID_ENREGISTRMNT"
)

# Pour charger un CSV volumineux, data.table::fread est généralement le plus rapide.
load_retour4c <- function(path, select_cols = NULL, sep = ",", dec = ".", nThread = 0) {
  # select_cols: si NULL, on lit tout; sinon on lit uniquement ces colonnes (gain mémoire)
  fread(
    file = path,
    sep = sep,
    dec = dec,
    select = select_cols,
    showProgress = TRUE,
    nThread = nThread
  )
}

synth_golden_source <- function(dt) {
  # dt: data.table Retour4C
  # Attendu: ASOF_DT, GoldenSource, SG_CONTRACT_ID, Encours, EAD, RWA
  x <- copy(dt)

  x[, ASOF := asof_to_date(ASOF_DT)]

  res <- x[, .(
    Nbre_contrat = uniqueN(SG_CONTRACT_ID),
    Encours_MEUR = sum(as.numeric(Encours), na.rm = TRUE) / 1e6,
    EAD_MEUR     = sum(as.numeric(EAD), na.rm = TRUE) / 1e6,
    RWA_MEUR     = sum(as.numeric(RWA), na.rm = TRUE) / 1e6
  ), by = .(ASOF, GoldenSource)]

  # Ajout ligne Total par date (toutes GoldenSource)
  total <- res[, .(
    Nbre_contrat = sum(Nbre_contrat, na.rm = TRUE),
    Encours_MEUR = sum(Encours_MEUR, na.rm = TRUE),
    EAD_MEUR     = sum(EAD_MEUR, na.rm = TRUE),
    RWA_MEUR     = sum(RWA_MEUR, na.rm = TRUE)
  ), by = .(ASOF)][, GoldenSource := "TOTAL"]

  rbind(res, total, fill = TRUE)[order(ASOF, GoldenSource)]
}

synth_portefeuille <- function(dt) {
  x <- copy(dt)
  x[, ASOF := asof_to_date(ASOF_DT)]

  res <- x[, .(
    Nbre_contrat = uniqueN(SG_CONTRACT_ID),
    Encours_MEUR = sum(as.numeric(Encours), na.rm = TRUE) / 1e6,
    EAD_MEUR     = sum(as.numeric(EAD), na.rm = TRUE) / 1e6,
    RWA_MEUR     = sum(as.numeric(RWA), na.rm = TRUE) / 1e6
  ), by = .(ASOF, PRTF)]

  total <- res[, .(
    Nbre_contrat = sum(Nbre_contrat, na.rm = TRUE),
    Encours_MEUR = sum(Encours_MEUR, na.rm = TRUE),
    EAD_MEUR     = sum(EAD_MEUR, na.rm = TRUE),
    RWA_MEUR     = sum(RWA_MEUR, na.rm = TRUE) / 1e0
  ), by = .(ASOF)][, PRTF := "TOTAL"]

  rbind(res, total, fill = TRUE)[order(ASOF, PRTF)]
}

##############################
# 3) Extraction anomalies DQ
##############################

# Recherche d'un ID_CONTRAT dans plusieurs colonnes d'identifiants du Retour4C
find_contract_rows <- function(ret_dt, ids_dt,
                               id_col = "ID_CONTRAT",
                               search_cols = c("SG_CONTRACT_ID", "SG_CONTR_BCE", "SG_CONTR_3D_ID", "SG_FACILITY_ID", "SG_ID_ENREGISTRMNT")) {
  stopifnot(is.data.table(ret_dt))
  stopifnot(is.data.table(ids_dt))
  ids <- unique(as.character(ids_dt[[id_col]]))
  ids <- ids[!is.na(ids) & ids != ""]

  # On “empile” (melt) les colonnes d'ID du Retour4C pour matcher sur une seule colonne
  # NB: sur 3Go, c'est potentiellement lourd; on limite aux colonnes nécessaires.
  base_cols <- intersect(c("ASOF_DT", "PRTF", "SSPRTF", "Segment", "PRODUCT_ID", "Encours", "EAD", "RWA"), names(ret_dt))
  keep_cols <- unique(c(base_cols, search_cols))
  tmp <- ret_dt[, ..keep_cols]

  long <- melt(
    tmp,
    measure.vars = intersect(search_cols, names(tmp)),
    variable.name = "ID_TYPE",
    value.name = "ID_VALUE",
    variable.factor = FALSE
  )

  long[, ID_VALUE := as.character(ID_VALUE)]
  long <- long[ID_VALUE %chin% ids]

  # Reconstitue extraction (une ligne par match)
  # Ajoute l'ID_CONTRAT (valeur recherchée)
  long[, ID_CONTRAT := ID_VALUE]
  # sélection finale
  out_cols <- c("ID_CONTRAT", "ID_TYPE", "ASOF_DT", "PRTF", "SSPRTF", "Segment", "PRODUCT_ID", "Encours", "EAD", "RWA")
  out_cols <- intersect(out_cols, names(long))
  long[, ..out_cols]
}

# Export Excel extraction
write_xlsx_safe <- function(dt, path) {
  wb <- createWorkbook()
  addWorksheet(wb, "data")
  writeDataTable(wb, "data", as.data.frame(dt))
  saveWorkbook(wb, path, overwrite = TRUE)
  path
}

##############################
# 4) Recalcul RWA corrigé pour anomalies
##############################
# anomalies_dq.xlsx attendu (au moins):
# ID_CONTRAT, EAD_corrige, RW_corrige, CCF_corrige, Surete (0/1)
#
# RWA_corrige (standard) : EAD_corrige * RW_corrige (ajusté surete/haircut si Surete=1)
# Comparaison vs Retour4C.RWA

recalc_rwa_from_anomalies <- function(extract_dt, anomalies_dt,
                                     haircut = 0.20, # exemple
                                     method = c("standard", "irba")) {
  method <- match.arg(method)
  stopifnot(is.data.table(extract_dt), is.data.table(anomalies_dt))

  a <- copy(anomalies_dt)
  e <- copy(extract_dt)

  a[, ID_CONTRAT := as.character(ID_CONTRAT)]
  e[, ID_CONTRAT := as.character(ID_CONTRAT)]

  # Merge (left sur anomalies)
  setkey(a, ID_CONTRAT)
  setkey(e, ID_CONTRAT)
  m <- e[a, nomatch = 0]

  # Normalisation champs
  for (col in c("EAD_corrige", "RW_corrige", "CCF_corrige", "Surete")) {
    if (!col %in% names(m)) m[, (col) := NA]
  }

  m[, Surete := as.integer(Surete)]
  m[, Surete := fifelse(is.na(Surete), 0L, Surete)]

  # Standard recalcul
  if (method == "standard") {
    # On préfère EAD_corrige si présent, sinon EAD (Retour4C)
    m[, EAD_used := fifelse(!is.na(EAD_corrige), as.numeric(EAD_corrige), as.numeric(EAD))]
    # RW corrigé sinon RW implicite: si absent on dérive RW = RWA/EAD
    m[, RW_used := fifelse(!is.na(RW_corrige), as.numeric(RW_corrige),
                           fifelse(as.numeric(EAD) > 0, as.numeric(RWA) / as.numeric(EAD), NA_real_))]

    # Haircut appliqué si surete=1
    m[, RWA_calc_corrige := std_rwa_with_collateral(
      ead = EAD_used,
      rw  = RW_used,
      surete = Surete,
      haircut = haircut
    )]
  } else {
    # IRBA: nécessite PD/LGD/M. Si non fournis dans anomalies, on ne peut pas recalculer.
    # Ici on met des placeholders et on laisse l'utilisateur enrichir anomalies_dt.
    for (col in c("PD_corrige", "LGD_corrige", "M_corrige", "IRB_scaling")) {
      if (!col %in% names(m)) m[, (col) := NA]
    }
    m[, EAD_used := fifelse(!is.na(EAD_corrige), as.numeric(EAD_corrige), as.numeric(EAD))]
    m[, PD_used  := as.numeric(PD_corrige)]
    m[, LGD_used := as.numeric(LGD_corrige)]
    m[, M_used   := fifelse(!is.na(M_corrige), as.numeric(M_corrige), 2.5)]
    m[, scaling  := fifelse(!is.na(IRB_scaling), as.numeric(IRB_scaling), 1.06)]

    # Déduit portefeuille IRB selon PRTF/SSPRTF
    m[, irb_portfolio := fifelse(
      tolower(PRTF) == "retail" & tolower(SSPRTF) == "immobilier", "retail_mortgage",
      fifelse(tolower(PRTF) == "retail" & tolower(SSPRTF) == "revolving", "retail_revolving",
              fifelse(tolower(PRTF) == "retail", "retail_other", "corporate")
      )
    )]

    # Recalcul IRB: si PD/LGD manquants -> NA
    m[, RWA_calc_corrige := fifelse(
      !is.na(PD_used) & !is.na(LGD_used),
      irb_rwa(pd = PD_used, lgd = LGD_used, ead = EAD_used, M = M_used,
              portfolio = irb_portfolio, apply_maturity = (irb_portfolio == "corporate"),
              scaling = scaling),
      NA_real_
    )]
  }

  # Comparaison vs RWA Retour4C
  m[, RWA_retour4c := as.numeric(RWA)]
  m[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]
  m[]
}

summarise_compare <- function(m) {
  # Synthèse par PRTF / SSPRTF
  cols <- intersect(c("PRTF", "SSPRTF"), names(m))
  if (length(cols) == 0) cols <- NULL

  if (!is.null(cols)) {
    m[, .(
      N = .N,
      RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm = TRUE) / 1e6,
      RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm = TRUE) / 1e6,
      Delta_MEUR        = sum(Delta_RWA, na.rm = TRUE) / 1e6
    ), by = cols][order(PRTF, SSPRTF)]
  } else {
    m[, .(
      N = .N,
      RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm = TRUE) / 1e6,
      RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm = TRUE) / 1e6,
      Delta_MEUR        = sum(Delta_RWA, na.rm = TRUE) / 1e6
    )]
  }
}

##############################
# 5) Module 1 - Calculateur RWA (UI + Server)
##############################
mod_calc_ui <- function(id) {
  ns <- NS(id)
  tagList(
    h3("1) Calcul RWA - Standard & IRBA (Retail / Non Retail)"),
    fluidRow(
      column(
        4,
        card(
          card_header("Paramètres"),
          selectInput(ns("method"), "Méthode", choices = c("Standard", "IRBA"), selected = "Standard"),
          selectInput(ns("prtf"), "Portefeuille bâlois", choices = c("Retail", "Non Retail"), selected = "Retail"),
          conditionalPanel(
            condition = sprintf("input['%s'] == 'Retail'", ns("prtf")),
            selectInput(ns("ssprtf"), "Sous-portefeuille Retail", choices = c("Immobilier", "Revolving", "Autres"), selected = "Immobilier")
          ),
          hr(),
          h5("1.1 / 1.3 - EAD & RW (initial vs corrigé)"),
          numericInput(ns("ead_init"), "EAD initial (EUR)", value = 1000000, min = 0, step = 1000),
          numericInput(ns("ead_corr"), "EAD corrigé (EUR)", value = 950000, min = 0, step = 1000),
          numericInput(ns("rw_init"),  "RW initial (%)", value = 75, min = 0, max = 300, step = 1),
          numericInput(ns("rw_corr"),  "RW corrigé (%)", value = 70, min = 0, max = 300, step = 1),

          hr(),
          h5("1.2 - Sûreté & haircut (Standard)"),
          checkboxInput(ns("has_collateral"), "Sûreté (Oui/Non)", value = FALSE),
          numericInput(ns("haircut"), "Haircut réglementaire (%)", value = 20, min = 0, max = 100, step = 1),

          hr(),
          h5("1.4 - Bilan / Hors bilan (Standard)"),
          numericInput(ns("ead_b_init"),  "EAD_B initial (EUR)", value = 800000, min = 0, step = 1000),
          numericInput(ns("ead_hb_init"), "EAD_HB initial (EUR)", value = 400000, min = 0, step = 1000),
          numericInput(ns("ccf_init"),    "CCF initial (%)", value = 50, min = 0, max = 100, step = 1),
          numericInput(ns("ead_b_corr"),  "EAD_B corrigé (EUR)", value = 780000, min = 0, step = 1000),
          numericInput(ns("ead_hb_corr"), "EAD_HB corrigé (EUR)", value = 350000, min = 0, step = 1000),
          numericInput(ns("ccf_corr"),    "CCF corrigé (%)", value = 45, min = 0, max = 100, step = 1),

          conditionalPanel(
            condition = sprintf("input['%s'] == 'IRBA'", ns("method")),
            hr(),
            h5("1.5 - Paramètres IRBA"),
            numericInput(ns("pd_init"), "PD initial (%)", value = 1.2, min = 0.001, max = 100, step = 0.1),
            numericInput(ns("pd_corr"), "PD corrigé (%)", value = 1.0, min = 0.001, max = 100, step = 0.1),
            numericInput(ns("lgd_init"), "LGD initial (%)", value = 45, min = 0, max = 100, step = 1),
            numericInput(ns("lgd_corr"), "LGD corrigé (%)", value = 40, min = 0, max = 100, step = 1),
            numericInput(ns("m_init"), "Maturité M initial (années)", value = 2.5, min = 0.5, max = 10, step = 0.1),
            numericInput(ns("m_corr"), "Maturité M corrigée (années)", value = 2.3, min = 0.5, max = 10, step = 0.1),
            numericInput(ns("irb_scaling"), "Scaling IRB (ex: 1.06)", value = 1.06, min = 0.5, max = 2, step = 0.01)
          )
        )
      ),
      column(
        8,
        card(
          card_header("Résultats (indépendants)"),
          h5("RWA Standard: correction RW / EAD / sûreté"),
          DTOutput(ns("tbl_std")),
          hr(),
          h5("RWA Bilan / Hors bilan (Standard)"),
          DTOutput(ns("tbl_bh")),
          conditionalPanel(
            condition = sprintf("input['%s'] == 'IRBA'", ns("method")),
            tagList(
              hr(),
              h5("RWA IRBA: initial vs corrigé"),
              DTOutput(ns("tbl_irb"))
            )
          ),
          hr(),
          h5("1.6 - Graphique RWA initial vs corrigé"),
          plotOutput(ns("plt_rwa"), height = "320px")
        )
      )
    )
  )
}

mod_calc_server <- function(id) {
  moduleServer(id, function(input, output, session) {

    # Helpers pour normaliser %
    pct <- function(x) as.numeric(x) / 100

    #---- Standard “global” initial/corrigé (1.1 + 1.3) avec option sûreté (1.2)
    std_res <- reactive({
      rw_init_d <- pct(input$rw_init)
      rw_corr_d <- pct(input$rw_corr)

      # 1.1: RW initial vs corrigé (EAD inchangé sur cette vue: EAD initial)
      rwa_rw_init <- std_rwa(input$ead_init, rw_init_d)
      rwa_rw_corr <- std_rwa(input$ead_init, rw_corr_d)

      # 1.3: EAD initial vs corrigé (RW initial)
      rwa_ead_init <- std_rwa(input$ead_init, rw_init_d)
      rwa_ead_corr <- std_rwa(input$ead_corr, rw_init_d)

      # 1.2: sûreté/haircut (sur EAD corrigé & RW corrigé par défaut)
      surete <- ifelse(isTRUE(input$has_collateral), 1L, 0L)
      haircut <- pct(input$haircut)
      rwa_with_collat <- std_rwa_with_collateral(input$ead_corr, rw_corr_d, surete = surete, haircut = haircut)

      data.table(
        Scenario = c(
          "1.1 RWA (EAD init, RW init)",
          "1.1 RWA (EAD init, RW corrigé)",
          "1.3 RWA (EAD init, RW init)",
          "1.3 RWA (EAD corrigé, RW init)",
          "1.2 RWA (EAD corrigé, RW corrigé, sûreté/haircut)"
        ),
        RWA_EUR = c(rwa_rw_init, rwa_rw_corr, rwa_ead_init, rwa_ead_corr, rwa_with_collat),
        Commentaire = c(
          "Différence = correction RW (Data Quality)",
          "Différence = correction RW (Data Quality)",
          "Référence EAD initial",
          "Différence = correction EAD (Data Quality)",
          ifelse(surete == 1, "Sûreté=Oui => EAD ajustée (haircut)", "Sûreté=Non")
        )
      )
    })

    output$tbl_std <- renderDT({
      datatable(std_res(), options = list(pageLength = 10), rownames = FALSE)
    })

    #---- 1.4 Bilan/Hors Bilan initial vs corrigé
    bh_res <- reactive({
      rw_init_d <- pct(input$rw_init)
      rw_corr_d <- pct(input$rw_corr)

      init <- std_rwa_bilan_hb(
        ead_b  = input$ead_b_init,
        ead_hb = input$ead_hb_init,
        ccf    = pct(input$ccf_init),
        rw     = rw_init_d
      )
      corr <- std_rwa_bilan_hb(
        ead_b  = input$ead_b_corr,
        ead_hb = input$ead_hb_corr,
        ccf    = pct(input$ccf_corr),
        rw     = rw_corr_d
      )

      data.table(
        Bloc = c("Bilan", "Hors bilan", "Total"),
        RWA_initial_EUR  = c(init$rwa_b, init$rwa_hb, init$rwa_total),
        RWA_corrige_EUR  = c(corr$rwa_b, corr$rwa_hb, corr$rwa_total),
        