################################################################################
# app.R - Application RShiny RWA Bâle (Standard + IRBA) + Retour4C (3Go+) + DQ
# Auteur : (à compléter)
# Objectif : Modules indépendants:
# 1) Calculateur RWA (Standard + IRBA) Retail/Non-Retail + corrections + graphe
# 2) Chargement Retour4C CSV très volumineux + minuteur + synthèses
# 3) Chargement anomalies_dq.xlsx + extraction contrats + export Excel
# 4) Recalcul RWA corrigé à partir anomalies + comparaison + export Excel
################################################################################

##############################
# 0) Packages + sécurité
##############################
required_pkgs <- c(
  "shiny", "bslib", "data.table", "DT", "ggplot2",
  "readxl", "openxlsx", "shinyjs"
)

missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, FUN.VALUE = logical(1), quietly = TRUE)]
if (length(missing_pkgs) > 0) {
  stop(
    "Packages manquants: ", paste(missing_pkgs, collapse = ", "),
    "\nInstalle-les avec: install.packages(c(", paste0('"', missing_pkgs, '"', collapse = ", "), "))"
  )
}

library(shiny)
library(bslib)
library(data.table)
library(DT)
library(ggplot2)
library(readxl)
library(openxlsx)
library(shinyjs)

options(shiny.maxRequestSize = 10 * 1024^3) # jusqu’à 10Go en upload si besoin

##############################
# 1) Fonctions RWA (Standard + IRBA)
##############################

#---------- 1.1 Standard: RWA = EAD * RW
std_rwa <- function(ead, rw) {
  # ead: numérique (EUR)
  # rw: poids en décimal (ex: 0.75 pour 75%)
  ead <- as.numeric(ead)
  rw  <- as.numeric(rw)
  ead * rw
}

#---------- 1.2 Standard + sûreté (CRM) avec haircuts (version simplifiée)
# Dans Bâle, l'exposition ajustée E* dépend du collatéral et des haircuts.
# Ici : si surete=1, on applique un haircut réglementaire "h" en réduisant EAD
# EAD_adj = EAD * (1 - h). A adapter si vous avez C (collatéral) explicite.
std_rwa_with_collateral <- function(ead, rw, surete = 0, haircut = 0) {
  ead <- as.numeric(ead)
  rw  <- as.numeric(rw)
  surete <- as.integer(surete)
  haircut <- as.numeric(haircut)
  haircut <- pmax(0, pmin(haircut, 1))

  ead_adj <- ifelse(surete == 1, ead * (1 - haircut), ead)
  std_rwa(ead_adj, rw)
}

#---------- 1.3 EAD bilan / hors bilan (standard)
# RWA_B = EAD_B * RW ; RWA_HB = (EAD_HB * CCF) * RW
std_rwa_bilan_hb <- function(ead_b, ead_hb, ccf, rw) {
  ead_b  <- as.numeric(ead_b)
  ead_hb <- as.numeric(ead_hb)
  ccf    <- as.numeric(ccf)
  rw     <- as.numeric(rw)

  rwa_b  <- std_rwa(ead_b, rw)
  rwa_hb <- std_rwa(ead_hb * ccf, rw)
  list(rwa_b = rwa_b, rwa_hb = rwa_hb, rwa_total = rwa_b + rwa_hb)
}

#---------- 1.4 IRBA : fonctions de base (approche IRB type BCBS)
# Implémentation classique:
#   K = LGD * N( (1/sqrt(1-R))*G(PD) + sqrt(R/(1-R))*G(0.999) ) - PD*LGD
#   K_adj (si maturity) = K * (1 + (M - 2.5)*b)/(1 - 1.5*b)
#   RWA = 12.5 * K_adj * EAD * scaling
#
# NB:
# - Retail: souvent pas d'ajustement de maturité (ou M fixé), selon cadre.
# - Les corrélations R diffèrent selon portefeuille.
# - Ici, on propose un paramètre "portfolio" pour choisir R.
#
N <- function(x) stats::pnorm(x)
G <- function(p) stats::qnorm(p)

irb_corr_R <- function(pd, portfolio = c("corporate", "retail_mortgage", "retail_revolving", "retail_other")) {
  portfolio <- match.arg(portfolio)
  pd <- as.numeric(pd)

  # Corrélations typiques (style Bâle II/III). Ajuster si votre doctrine interne Bâle IV diffère.
  if (portfolio == "corporate") {
    # Corporate / Non-retail générique
    R <- 0.12 * (1 - exp(-50 * pd)) / (1 - exp(-50)) +
      0.24 * (1 - (1 - exp(-50 * pd)) / (1 - exp(-50)))
  } else if (portfolio == "retail_mortgage") {
    # Immobilier résidentiel
    R <- 0.15
  } else if (portfolio == "retail_revolving") {
    # Revolving qualifié
    R <- 0.04
  } else {
    # Retail autres
    R <- 0.03 * (1 - exp(-35 * pd)) / (1 - exp(-35)) +
      0.16 * (1 - (1 - exp(-35 * pd)) / (1 - exp(-35)))
  }
  pmax(0, pmin(R, 0.999))
}

irb_maturity_b <- function(pd) {
  pd <- as.numeric(pd)
  (0.11852 - 0.05478 * log(pmax(pd, 1e-10)))^2
}

irb_k <- function(pd, lgd, R) {
  pd  <- as.numeric(pd)
  lgd <- as.numeric(lgd)
  R   <- as.numeric(R)

  # garde-fous
  pd  <- pmax(1e-10, pmin(pd, 1 - 1e-10))
  lgd <- pmax(0, pmin(lgd, 1))
  R   <- pmax(0, pmin(R, 0.999))

  d <- (1 / sqrt(1 - R)) * G(pd) + sqrt(R / (1 - R)) * G(0.999)
  lgd * N(d) - pd * lgd
}

irb_rwa <- function(pd, lgd, ead, M = 2.5, portfolio = "corporate",
                    apply_maturity = TRUE, scaling = 1.06) {
  pd  <- as.numeric(pd)
  lgd <- as.numeric(lgd)
  ead <- as.numeric(ead)
  M   <- as.numeric(M)
  scaling <- as.numeric(scaling)

  R <- irb_corr_R(pd, portfolio = portfolio)
  K <- irb_k(pd, lgd, R)

  if (apply_maturity) {
    b <- irb_maturity_b(pd)
    K_adj <- K * (1 + (M - 2.5) * b) / (1 - 1.5 * b)
  } else {
    K_adj <- K
  }

  12.5 * K_adj * ead * scaling
}

##############################
# 2) Utilitaires Retour4C (gros CSV)
##############################

# Lecture robuste date ASOF_DT
asof_to_date <- function(x) {
  # tente plusieurs formats
  if (inherits(x, "Date")) return(x)
  x <- as.character(x)
  # Essais: yyyy-mm-dd, dd/mm/yyyy, yyyymmdd
  out <- suppressWarnings(as.Date(x, format = "%Y-%m-%d"))
  if (all(is.na(out))) out <- suppressWarnings(as.Date(x, format = "%d/%m/%Y"))
  if (all(is.na(out))) out <- suppressWarnings(as.Date(x, format = "%Y%m%d"))
  out
}

# Synthèses demandées:
# - par GoldenSource
# - par portefeuille bâlois (PRTF)
# Colonnes attendues (à adapter à ton CSV): ASOF_DT, GoldenSource, SG_CONTRACT_ID,
# Encours, EAD, RWA, PRTF, Segment, PRODUCT_ID, SSPRTF ...
#
# IMPORTANT: si tes noms de colonnes diffèrent, ajuste les vecteurs ci-dessous.
RET_COLS_MIN <- c(
  "ASOF_DT", "GoldenSource", "SG_CONTRACT_ID",
  "Encours", "EAD", "RWA",
  "PRTF", "SSPRTF", "Segment", "PRODUCT_ID",
  "SG_CONTR_BCE", "SG_CONTR_3D_ID", "SG_FACILITY_ID", "SG_ID_ENREGISTRMNT"
)

# Pour charger un CSV volumineux, data.table::fread est généralement le plus rapide.
load_retour4c <- function(path, select_cols = NULL, sep = ",", dec = ".", nThread = 0) {
  # select_cols: si NULL, on lit tout; sinon on lit uniquement ces colonnes (gain mémoire)
  fread(
    file = path,
    sep = sep,
    dec = dec,
    select = select_cols,
    showProgress = TRUE,
    nThread = nThread
  )
}

synth_golden_source <- function(dt) {
  # dt: data.table Retour4C
  # Attendu: ASOF_DT, GoldenSource, SG_CONTRACT_ID, Encours, EAD, RWA
  x <- copy(dt)

  x[, ASOF := asof_to_date(ASOF_DT)]

  res <- x[, .(
    Nbre_contrat = uniqueN(SG_CONTRACT_ID),
    Encours_MEUR = sum(as.numeric(Encours), na.rm = TRUE) / 1e6,
    EAD_MEUR     = sum(as.numeric(EAD), na.rm = TRUE) / 1e6,
    RWA_MEUR     = sum(as.numeric(RWA), na.rm = TRUE) / 1e6
  ), by = .(ASOF, GoldenSource)]

  # Ajout ligne Total par date (toutes GoldenSource)
  total <- res[, .(
    Nbre_contrat = sum(Nbre_contrat, na.rm = TRUE),
    Encours_MEUR = sum(Encours_MEUR, na.rm = TRUE),
    EAD_MEUR     = sum(EAD_MEUR, na.rm = TRUE),
    RWA_MEUR     = sum(RWA_MEUR, na.rm = TRUE)
  ), by = .(ASOF)][, GoldenSource := "TOTAL"]

  rbind(res, total, fill = TRUE)[order(ASOF, GoldenSource)]
}

synth_portefeuille <- function(dt) {
  x <- copy(dt)
  x[, ASOF := asof_to_date(ASOF_DT)]

  res <- x[, .(
    Nbre_contrat = uniqueN(SG_CONTRACT_ID),
    Encours_MEUR = sum(as.numeric(Encours), na.rm = TRUE) / 1e6,
    EAD_MEUR     = sum(as.numeric(EAD), na.rm = TRUE) / 1e6,
    RWA_MEUR     = sum(as.numeric(RWA), na.rm = TRUE) / 1e6
  ), by = .(ASOF, PRTF)]

  total <- res[, .(
    Nbre_contrat = sum(Nbre_contrat, na.rm = TRUE),
    Encours_MEUR = sum(Encours_MEUR, na.rm = TRUE),
    EAD_MEUR     = sum(EAD_MEUR, na.rm = TRUE),
    RWA_MEUR     = sum(RWA_MEUR, na.rm = TRUE) / 1e0
  ), by = .(ASOF)][, PRTF := "TOTAL"]

  rbind(res, total, fill = TRUE)[order(ASOF, PRTF)]
}

##############################
# 3) Extraction anomalies DQ
##############################

# Recherche d'un ID_CONTRAT dans plusieurs colonnes d'identifiants du Retour4C
find_contract_rows <- function(ret_dt, ids_dt,
                               id_col = "ID_CONTRAT",
                               search_cols = c("SG_CONTRACT_ID", "SG_CONTR_BCE", "SG_CONTR_3D_ID", "SG_FACILITY_ID", "SG_ID_ENREGISTRMNT")) {
  stopifnot(is.data.table(ret_dt))
  stopifnot(is.data.table(ids_dt))
  ids <- unique(as.character(ids_dt[[id_col]]))
  ids <- ids[!is.na(ids) & ids != ""]

  # On “empile” (melt) les colonnes d'ID du Retour4C pour matcher sur une seule colonne
  # NB: sur 3Go, c'est potentiellement lourd; on limite aux colonnes nécessaires.
  base_cols <- intersect(c("ASOF_DT", "PRTF", "SSPRTF", "Segment", "PRODUCT_ID", "Encours", "EAD", "RWA"), names(ret_dt))
  keep_cols <- unique(c(base_cols, search_cols))
  tmp <- ret_dt[, ..keep_cols]

  long <- melt(
    tmp,
    measure.vars = intersect(search_cols, names(tmp)),
    variable.name = "ID_TYPE",
    value.name = "ID_VALUE",
    variable.factor = FALSE
  )

  long[, ID_VALUE := as.character(ID_VALUE)]
  long <- long[ID_VALUE %chin% ids]

  # Reconstitue extraction (une ligne par match)
  # Ajoute l'ID_CONTRAT (valeur recherchée)
  long[, ID_CONTRAT := ID_VALUE]
  # sélection finale
  out_cols <- c("ID_CONTRAT", "ID_TYPE", "ASOF_DT", "PRTF", "SSPRTF", "Segment", "PRODUCT_ID", "Encours", "EAD", "RWA")
  out_cols <- intersect(out_cols, names(long))
  long[, ..out_cols]
}

# Export Excel extraction
write_xlsx_safe <- function(dt, path) {
  wb <- createWorkbook()
  addWorksheet(wb, "data")
  writeDataTable(wb, "data", as.data.frame(dt))
  saveWorkbook(wb, path, overwrite = TRUE)
  path
}

##############################
# 4) Recalcul RWA corrigé pour anomalies
##############################
# anomalies_dq.xlsx attendu (au moins):
# ID_CONTRAT, EAD_corrige, RW_corrige, CCF_corrige, Surete (0/1)
#
# RWA_corrige (standard) : EAD_corrige * RW_corrige (ajusté surete/haircut si Surete=1)
# Comparaison vs Retour4C.RWA

recalc_rwa_from_anomalies <- function(extract_dt, anomalies_dt,
                                     haircut = 0.20, # exemple
                                     method = c("standard", "irba")) {
  method <- match.arg(method)
  stopifnot(is.data.table(extract_dt), is.data.table(anomalies_dt))

  a <- copy(anomalies_dt)
  e <- copy(extract_dt)

  a[, ID_CONTRAT := as.character(ID_CONTRAT)]
  e[, ID_CONTRAT := as.character(ID_CONTRAT)]

  # Merge (left sur anomalies)
  setkey(a, ID_CONTRAT)
  setkey(e, ID_CONTRAT)
  m <- e[a, nomatch = 0]

  # Normalisation champs
  for (col in c("EAD_corrige", "RW_corrige", "CCF_corrige", "Surete")) {
    if (!col %in% names(m)) m[, (col) := NA]
  }

  m[, Surete := as.integer(Surete)]
  m[, Surete := fifelse(is.na(Surete), 0L, Surete)]

  # Standard recalcul
  if (method == "standard") {
    # On préfère EAD_corrige si présent, sinon EAD (Retour4C)
    m[, EAD_used := fifelse(!is.na(EAD_corrige), as.numeric(EAD_corrige), as.numeric(EAD))]
    # RW corrigé sinon RW implicite: si absent on dérive RW = RWA/EAD
    m[, RW_used := fifelse(!is.na(RW_corrige), as.numeric(RW_corrige),
                           fifelse(as.numeric(EAD) > 0, as.numeric(RWA) / as.numeric(EAD), NA_real_))]

    # Haircut appliqué si surete=1
    m[, RWA_calc_corrige := std_rwa_with_collateral(
      ead = EAD_used,
      rw  = RW_used,
      surete = Surete,
      haircut = haircut
    )]
  } else {
    # IRBA: nécessite PD/LGD/M. Si non fournis dans anomalies, on ne peut pas recalculer.
    # Ici on met des placeholders et on laisse l'utilisateur enrichir anomalies_dt.
    for (col in c("PD_corrige", "LGD_corrige", "M_corrige", "IRB_scaling")) {
      if (!col %in% names(m)) m[, (col) := NA]
    }
    m[, EAD_used := fifelse(!is.na(EAD_corrige), as.numeric(EAD_corrige), as.numeric(EAD))]
    m[, PD_used  := as.numeric(PD_corrige)]
    m[, LGD_used := as.numeric(LGD_corrige)]
    m[, M_used   := fifelse(!is.na(M_corrige), as.numeric(M_corrige), 2.5)]
    m[, scaling  := fifelse(!is.na(IRB_scaling), as.numeric(IRB_scaling), 1.06)]

    # Déduit portefeuille IRB selon PRTF/SSPRTF
    m[, irb_portfolio := fifelse(
      tolower(PRTF) == "retail" & tolower(SSPRTF) == "immobilier", "retail_mortgage",
      fifelse(tolower(PRTF) == "retail" & tolower(SSPRTF) == "revolving", "retail_revolving",
              fifelse(tolower(PRTF) == "retail", "retail_other", "corporate")
      )
    )]

    # Recalcul IRB: si PD/LGD manquants -> NA
    m[, RWA_calc_corrige := fifelse(
      !is.na(PD_used) & !is.na(LGD_used),
      irb_rwa(pd = PD_used, lgd = LGD_used, ead = EAD_used, M = M_used,
              portfolio = irb_portfolio, apply_maturity = (irb_portfolio == "corporate"),
              scaling = scaling),
      NA_real_
    )]
  }

  # Comparaison vs RWA Retour4C
  m[, RWA_retour4c := as.numeric(RWA)]
  m[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]
  m[]
}

summarise_compare <- function(m) {
  # Synthèse par PRTF / SSPRTF
  cols <- intersect(c("PRTF", "SSPRTF"), names(m))
  if (length(cols) == 0) cols <- NULL

  if (!is.null(cols)) {
    m[, .(
      N = .N,
      RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm = TRUE) / 1e6,
      RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm = TRUE) / 1e6,
      Delta_MEUR        = sum(Delta_RWA, na.rm = TRUE) / 1e6
    ), by = cols][order(PRTF, SSPRTF)]
  } else {
    m[, .(
      N = .N,
      RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm = TRUE) / 1e6,
      RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm = TRUE) / 1e6,
      Delta_MEUR        = sum(Delta_RWA, na.rm = TRUE) / 1e6
    )]
  }
}

##############################
# 5) Module 1 - Calculateur RWA (UI + Server)
##############################
mod_calc_ui <- function(id) {
  ns <- NS(id)
  tagList(
    h3("1) Calcul RWA - Standard & IRBA (Retail / Non Retail)"),
    fluidRow(
      column(
        4,
        card(
          card_header("Paramètres"),
          selectInput(ns("method"), "Méthode", choices = c("Standard", "IRBA"), selected = "Standard"),
          selectInput(ns("prtf"), "Portefeuille bâlois", choices = c("Retail", "Non Retail"), selected = "Retail"),
          conditionalPanel(
            condition = sprintf("input['%s'] == 'Retail'", ns("prtf")),
            selectInput(ns("ssprtf"), "Sous-portefeuille Retail", choices = c("Immobilier", "Revolving", "Autres"), selected = "Immobilier")
          ),
          hr(),
          h5("1.1 / 1.3 - EAD & RW (initial vs corrigé)"),
          numericInput(ns("ead_init"), "EAD initial (EUR)", value = 1000000, min = 0, step = 1000),
          numericInput(ns("ead_corr"), "EAD corrigé (EUR)", value = 950000, min = 0, step = 1000),
          numericInput(ns("rw_init"),  "RW initial (%)", value = 75, min = 0, max = 300, step = 1),
          numericInput(ns("rw_corr"),  "RW corrigé (%)", value = 70, min = 0, max = 300, step = 1),

          hr(),
          h5("1.2 - Sûreté & haircut (Standard)"),
          checkboxInput(ns("has_collateral"), "Sûreté (Oui/Non)", value = FALSE),
          numericInput(ns("haircut"), "Haircut réglementaire (%)", value = 20, min = 0, max = 100, step = 1),

          hr(),
          h5("1.4 - Bilan / Hors bilan (Standard)"),
          numericInput(ns("ead_b_init"),  "EAD_B initial (EUR)", value = 800000, min = 0, step = 1000),
          numericInput(ns("ead_hb_init"), "EAD_HB initial (EUR)", value = 400000, min = 0, step = 1000),
          numericInput(ns("ccf_init"),    "CCF initial (%)", value = 50, min = 0, max = 100, step = 1),
          numericInput(ns("ead_b_corr"),  "EAD_B corrigé (EUR)", value = 780000, min = 0, step = 1000),
          numericInput(ns("ead_hb_corr"), "EAD_HB corrigé (EUR)", value = 350000, min = 0, step = 1000),
          numericInput(ns("ccf_corr"),    "CCF corrigé (%)", value = 45, min = 0, max = 100, step = 1),

          conditionalPanel(
            condition = sprintf("input['%s'] == 'IRBA'", ns("method")),
            hr(),
            h5("1.5 - Paramètres IRBA"),
            numericInput(ns("pd_init"), "PD initial (%)", value = 1.2, min = 0.001, max = 100, step = 0.1),
            numericInput(ns("pd_corr"), "PD corrigé (%)", value = 1.0, min = 0.001, max = 100, step = 0.1),
            numericInput(ns("lgd_init"), "LGD initial (%)", value = 45, min = 0, max = 100, step = 1),
            numericInput(ns("lgd_corr"), "LGD corrigé (%)", value = 40, min = 0, max = 100, step = 1),
            numericInput(ns("m_init"), "Maturité M initial (années)", value = 2.5, min = 0.5, max = 10, step = 0.1),
            numericInput(ns("m_corr"), "Maturité M corrigée (années)", value = 2.3, min = 0.5, max = 10, step = 0.1),
            numericInput(ns("irb_scaling"), "Scaling IRB (ex: 1.06)", value = 1.06, min = 0.5, max = 2, step = 0.01)
          )
        )
      ),
      column(
        8,
        card(
          card_header("Résultats (indépendants)"),
          h5("RWA Standard: correction RW / EAD / sûreté"),
          DTOutput(ns("tbl_std")),
          hr(),
          h5("RWA Bilan / Hors bilan (Standard)"),
          DTOutput(ns("tbl_bh")),
          conditionalPanel(
            condition = sprintf("input['%s'] == 'IRBA'", ns("method")),
            tagList(
              hr(),
              h5("RWA IRBA: initial vs corrigé"),
              DTOutput(ns("tbl_irb"))
            )
          ),
          hr(),
          h5("1.6 - Graphique RWA initial vs corrigé"),
          plotOutput(ns("plt_rwa"), height = "320px")
        )
      )
    )
  )
}

mod_calc_server <- function(id) {
  moduleServer(id, function(input, output, session) {

    # Helpers pour normaliser %
    pct <- function(x) as.numeric(x) / 100

    #---- Standard “global” initial/corrigé (1.1 + 1.3) avec option sûreté (1.2)
    std_res <- reactive({
      rw_init_d <- pct(input$rw_init)
      rw_corr_d <- pct(input$rw_corr)

      # 1.1: RW initial vs corrigé (EAD inchangé sur cette vue: EAD initial)
      rwa_rw_init <- std_rwa(input$ead_init, rw_init_d)
      rwa_rw_corr <- std_rwa(input$ead_init, rw_corr_d)

      # 1.3: EAD initial vs corrigé (RW initial)
      rwa_ead_init <- std_rwa(input$ead_init, rw_init_d)
      rwa_ead_corr <- std_rwa(input$ead_corr, rw_init_d)

      # 1.2: sûreté/haircut (sur EAD corrigé & RW corrigé par défaut)
      surete <- ifelse(isTRUE(input$has_collateral), 1L, 0L)
      haircut <- pct(input$haircut)
      rwa_with_collat <- std_rwa_with_collateral(input$ead_corr, rw_corr_d, surete = surete, haircut = haircut)

      data.table(
        Scenario = c(
          "1.1 RWA (EAD init, RW init)",
          "1.1 RWA (EAD init, RW corrigé)",
          "1.3 RWA (EAD init, RW init)",
          "1.3 RWA (EAD corrigé, RW init)",
          "1.2 RWA (EAD corrigé, RW corrigé, sûreté/haircut)"
        ),
        RWA_EUR = c(rwa_rw_init, rwa_rw_corr, rwa_ead_init, rwa_ead_corr, rwa_with_collat),
        Commentaire = c(
          "Différence = correction RW (Data Quality)",
          "Différence = correction RW (Data Quality)",
          "Référence EAD initial",
          "Différence = correction EAD (Data Quality)",
          ifelse(surete == 1, "Sûreté=Oui => EAD ajustée (haircut)", "Sûreté=Non")
        )
      )
    })

    output$tbl_std <- renderDT({
      datatable(std_res(), options = list(pageLength = 10), rownames = FALSE)
    })

    #---- 1.4 Bilan/Hors Bilan initial vs corrigé
    bh_res <- reactive({
      rw_init_d <- pct(input$rw_init)
      rw_corr_d <- pct(input$rw_corr)

      init <- std_rwa_bilan_hb(
        ead_b  = input$ead_b_init,
        ead_hb = input$ead_hb_init,
        ccf    = pct(input$ccf_init),
        rw     = rw_init_d
      )
      corr <- std_rwa_bilan_hb(
        ead_b  = input$ead_b_corr,
        ead_hb = input$ead_hb_corr,
        ccf    = pct(input$ccf_corr),
        rw     = rw_corr_d
      )

      data.table(
        Bloc = c("Bilan", "Hors bilan", "Total"),
        RWA_initial_EUR  = c(init$rwa_b, init$rwa_hb, init$rwa_total),
        RWA_corrige_EUR  = c(corr$rwa_b, corr$rwa_hb, corr$rwa_total),
        Delta_EUR        = c(corr$rwa_b - init$rwa_b, corr$rwa_hb - init$rwa_hb, corr$rwa_total - init$rwa_total)
      )
    })

    output$tbl_bh <- renderDT({
      datatable(bh_res(), options = list(pageLength = 10), rownames = FALSE)
    })

    #---- 1.5 IRBA initial vs corrigé (adapter fonctionnalités précédentes)
    # Ici: on applique le principe "initial vs corrigé" sur PD/LGD/M/EAD
    irb_res <- reactive({
      req(input$method == "IRBA")

      # Déduction du portefeuille IRB selon PRTF/SSPRTF
      irb_port <- if (input$prtf == "Non Retail") {
        "corporate"
      } else {
        if (input$ssprtf == "Immobilier") "retail_mortgage"
        else if (input$ssprtf == "Revolving") "retail_revolving"
        else "retail_other"
      }

      # Retail: souvent pas d'ajustement maturité dans la formule standard IRB.
      apply_maturity <- (irb_port == "corporate")

      rwa_init <- irb_rwa(
        pd = pct(input$pd_init),
        lgd = pct(input$lgd_init),
        ead = input$ead_init,
        M = input$m_init,
        portfolio = irb_port,
        apply_maturity = apply_maturity,
        scaling = input$irb_scaling
      )

      rwa_corr <- irb_rwa(
        pd = pct(input$pd_corr),
        lgd = pct(input$lgd_corr),
        ead = input$ead_corr,
        M = input$m_corr,
        portfolio = irb_port,
        apply_maturity = apply_maturity,
        scaling = input$irb_scaling
      )

      data.table(
        Methode = "IRBA",
        Portefeuille_IRB = irb_port,
        RWA_initial_EUR = rwa_init,
        RWA_corrige_EUR = rwa_corr,
        Delta_EUR = rwa_corr - rwa_init
      )
    })

    output$tbl_irb <- renderDT({
      req(input$method == "IRBA")
      datatable(irb_res(), options = list(pageLength = 10), rownames = FALSE)
    })

    #---- 1.6 Graphique (RWA initial vs corrigé)
    output$plt_rwa <- renderPlot({
      # On trace (Standard) : une comparaison simple entre 2 points init/corr.
      # Si IRBA: on ajoute une série IRBA.
      rw_init_d <- pct(input$rw_init)
      rw_corr_d <- pct(input$rw_corr)
      surete <- ifelse(isTRUE(input$has_collateral), 1L, 0L)
      haircut <- pct(input$haircut)

      rwa_std_init <- std_rwa(input$ead_init, rw_init_d)
      rwa_std_corr <- std_rwa_with_collateral(input$ead_corr, rw_corr_d, surete = surete, haircut = haircut)

      df <- data.table(
        Methode = "Standard",
        Etat = c("Initial", "Corrigé"),
        RWA_EUR = c(rwa_std_init, rwa_std_corr)
      )

      if (input$method == "IRBA") {
        irb <- irb_res()
        df <- rbind(
          df,
          data.table(Methode = "IRBA", Etat = c("Initial", "Corrigé"), RWA_EUR = c(irb$RWA_initial_EUR, irb$RWA_corrige_EUR))
        )
      }

      ggplot(df, aes(x = Etat, y = RWA_EUR, group = Methode)) +
        geom_col(position = "dodge") +
        facet_wrap(~ Methode, scales = "free_y") +
        labs(x = NULL, y = "RWA (EUR)") +
        theme_minimal(base_size = 12)
    })
  })
}

##############################
# 6) Module 2 - Chargement Retour4C + minuteur + synthèses
##############################
mod_retour4c_ui <- function(id) {
  ns <- NS(id)
  tagList(
    h3("2) Chargement Retour4C (CSV 3Go+) + Synthèses"),
    fluidRow(
      column(
        4,
        card(
          card_header("Chargement fichier Retour4C"),
          fileInput(ns("csv_file"), "Retour4C (CSV)", accept = c(".csv", ".txt")),
          textInput(ns("sep"), "Séparateur", value = ","),
          textInput(ns("dec"), "Décimal", value = "."),
          checkboxInput(ns("select_min_cols"), "Charger seulement colonnes minimales (recommandé)", TRUE),
          actionButton(ns("btn_load"), "Charger Retour4C", class = "btn-primary"),
          hr(),
          uiOutput(ns("load_status"))
        )
      ),
      column(
        8,
        card(
          card_header("Informations & Synthèses"),
          uiOutput(ns("asof_info")),
          hr(),
          h4("Synthèse par Golden source"),
          DTOutput(ns("tbl_gs")),
          hr(),
          h4("Synthèse par portefeuille Bâlois"),
          DTOutput(ns("tbl_prtf"))
        )
      )
    )
  )
}

mod_retour4c_server <- function(id) {
  moduleServer(id, function(input, output, session) {

    retour_dt <- reactiveVal(NULL)

    # minuteur
    loading <- reactiveVal(FALSE)
    t0 <- reactiveVal(NULL)

    output$load_status <- renderUI({
      if (!isTRUE(loading())) {
        return(tags$span(class = "text-muted", "Aucun fichier chargé."))
      }

      # minuteur live
      invalidateLater(500, session)
      elapsed <- as.numeric(difftime(Sys.time(), t0(), units = "secs"))
      tags$div(
        tags$strong("Fichier en cours de chargement... "),
        tags$span(sprintf("(%0.1f s)", elapsed))
      )
    })

    observeEvent(input$btn_load, {
      req(input$csv_file)

      loading(TRUE)
      t0(Sys.time())

      # feedback visuel (progress bar)
      withProgress(message = "Chargement Retour4C...", value = 0, {
        incProgress(0.1)

        path <- input$csv_file$datapath
        sep  <- input$sep
        dec  <- input$dec

        # lecture : colonnes minimales si demandé
        select_cols <- if (isTRUE(input$select_min_cols)) RET_COLS_MIN else NULL
        incProgress(0.2)

        dt <- tryCatch({
          load_retour4c(path, select_cols = select_cols, sep = sep, dec = dec, nThread = 0)
        }, error = function(e) {
          showNotification(paste("Erreur chargement:", e$message), type = "error", duration = 10)
          NULL
        })

        incProgress(0.8)

        if (!is.null(dt)) {
          setDT(dt)
          retour_dt(dt)
          showNotification("Fichier chargé avec succès...", type = "message", duration = 6)
        }
      })

      loading(FALSE)
    })

    # Afficher arrêté du fichier (max ASOF_DT)
    output$asof_info <- renderUI({
      dt <- retour_dt()
      if (is.null(dt)) return(NULL)

      if (!"ASOF_DT" %in% names(dt)) {
        return(tags$div(class = "text-danger", "Colonne ASOF_DT manquante dans Retour4C."))
      }

      asof <- asof_to_date(dt$ASOF_DT)
      max_asof <- suppressWarnings(max(asof, na.rm = TRUE))

      tags$div(
        tags$p(tags$strong("Arrêté du fichier (ASOF_DT): "), format(max_asof, "%d/%m/%Y")),
        tags$p(tags$strong("Taille (lignes x colonnes): "), paste(nrow(dt), "x", ncol(dt)))
      )
    })

    # tables synthèses
    output$tbl_gs <- renderDT({
      dt <- retour_dt()
      req(dt)
      if (!all(c("ASOF_DT", "GoldenSource", "SG_CONTRACT_ID", "Encours", "EAD", "RWA") %in% names(dt))) {
        return(datatable(data.table(Info = "Colonnes manquantes pour synthèse GoldenSource."), rownames = FALSE))
      }
      datatable(synth_golden_source(dt), options = list(pageLength = 25), rownames = FALSE)
    })

    output$tbl_prtf <- renderDT({
      dt <- retour_dt()
      req(dt)
      if (!all(c("ASOF_DT", "PRTF", "SG_CONTRACT_ID", "Encours", "EAD", "RWA") %in% names(dt))) {
        return(datatable(data.table(Info = "Colonnes manquantes pour synthèse Portefeuille."), rownames = FALSE))
      }
      datatable(synth_portefeuille(dt), options = list(pageLength = 25), rownames = FALSE)
    })

    # Expose dt aux autres modules
    return(list(retour_dt = retour_dt))
  })
}

##############################
# 7) Module 3 - Chargement anomalies + extraction + export + head/tail
##############################
mod_anom_ui <- function(id) {
  ns <- NS(id)
  tagList(
    h3("3) Anomalies DQ (Excel) -> Extraction dans Retour4C -> Export"),
    fluidRow(
      column(
        4,
        card(
          card_header("Charger anomalies_dq.xlsx"),
          fileInput(ns("anom_file"), "anomalies_dq.xlsx", accept = c(".xlsx")),
          actionButton(ns("btn_extract"), "Extraire contrats", class = "btn-primary"),
          hr(),
          downloadButton(ns("dl_extract"), "Télécharger ead_rwa_ano_dq.xlsx")
        )
      ),
      column(
        8,
        card(
          card_header("Aperçu extraction"),
          h5("5 premières lignes"),
          DTOutput(ns("tbl_head")),
          hr(),
          h5("5 dernières lignes"),
          DTOutput(ns("tbl_tail"))
        )
      )
    )
  )
}

mod_anom_server <- function(id, retour_dt_r) {
  moduleServer(id, function(input, output, session) {

    extract_dt <- reactiveVal(NULL)
    extract_path <- reactiveVal(NULL)

    observeEvent(input$btn_extract, {
      req(input$anom_file)
      ret <- retour_dt_r()
      req(ret)

      # Lecture anomalies
      anom <- tryCatch({
        as.data.table(read_excel(input$anom_file$datapath))
      }, error = function(e) {
        showNotification(paste("Erreur lecture Excel:", e$message), type = "error", duration = 10)
        NULL
      })
      req(anom)

      if (!"ID_CONTRAT" %in% names(anom)) {
        showNotification("Colonne ID_CONTRAT absente dans anomalies_dq.xlsx", type = "error", duration = 10)
        return()
      }

      withProgress(message = "Extraction des contrats...", value = 0, {
        incProgress(0.2)

        out <- tryCatch({
          find_contract_rows(ret, anom)
        }, error = function(e) {
          showNotification(paste("Erreur extraction:", e$message), type = "error", duration = 10)
          NULL
        })
        req(out)

        incProgress(0.8)

        extract_dt(out)

        # Export Excel
        out_file <- file.path(tempdir(), "ead_rwa_ano_dq.xlsx")
        write_xlsx_safe(out, out_file)
        extract_path(out_file)

        showNotification("Extraction terminée + fichier Excel généré.", type = "message", duration = 6)
      })
    })

    output$tbl_head <- renderDT({
      dt <- extract_dt()
      req(dt)
      datatable(head(dt, 5), options = list(dom = "t"), rownames = FALSE)
    })

    output$tbl_tail <- renderDT({
      dt <- extract_dt()
      req(dt)
      datatable(tail(dt, 5), options = list(dom = "t"), rownames = FALSE)
    })

    output$dl_extract <- downloadHandler(
      filename = function() "ead_rwa_ano_dq.xlsx",
      content = function(file) {
        req(extract_path())
        file.copy(extract_path(), file, overwrite = TRUE)
      }
    )

    return(list(extract_dt = extract_dt))
  })
}

##############################
# 8) Module 4 - Recalcul RWA corrigé (anomalies) + comparaison + export
##############################
mod_recalc_ui <- function(id) {
  ns <- NS(id)
  tagList(
    h3("4) Recalcul RWA corrigé (anomalies) + comparaison vs Retour4C"),
    fluidRow(
      column(
        4,
        card(
          card_header("Paramètres recalcul"),
          fileInput(ns("anom_file2"), "anomalies_dq.xlsx (avec EAD_corrige, RW_corrige, CCF_corrige, Surete)", accept = c(".xlsx")),
          selectInput(ns("method2"), "Méthode recalcul", choices = c("standard", "irba"), selected = "standard"),
          numericInput(ns("haircut2"), "Haircut (%) si Surete=1", value = 20, min = 0, max = 100, step = 1),
          actionButton(ns("btn_recalc"), "Recalculer & Comparer", class = "btn-primary"),
          hr(),
          downloadButton(ns("dl_recalc"), "Télécharger résultats (Excel)")
        )
      ),
      column(
        8,
        card(
          card_header("Synthèse & Détails"),
          h4("Synthèse (par PRTF / SSPRTF)"),
          DTOutput(ns("tbl_sum")),
          hr(),
          h4("Détails (extrait)"),
          DTOutput(ns("tbl_details"))
        )
      )
    )
  )
}

mod_recalc_server <- function(id, retour_dt_r) {
  moduleServer(id, function(input, output, session) {

    out_dt <- reactiveVal(NULL)
    out_path <- reactiveVal(NULL)

    observeEvent(input$btn_recalc, {
      req(input$anom_file2)
      ret <- retour_dt_r()
      req(ret)

      anom <- tryCatch({
        as.data.table(read_excel(input$anom_file2$datapath))
      }, error = function(e) {
        showNotification(paste("Erreur lecture Excel:", e$message), type = "error", duration = 10)
        NULL
      })
      req(anom)

      if (!"ID_CONTRAT" %in% names(anom)) {
        showNotification("Colonne ID_CONTRAT absente dans anomalies_dq.xlsx", type = "error", duration = 10)
        return()
      }

      # On réutilise la logique d'extraction : on récupère les lignes Retour4C correspondant aux IDs
      withProgress(message = "Matching + Recalcul RWA...", value = 0, {
        incProgress(0.2)

        extract <- tryCatch({
          find_contract_rows(ret, anom)
        }, error = function(e) {
          showNotification(paste("Erreur matching:", e$message), type = "error", duration = 10)
          NULL
        })
        req(extract)

        incProgress(0.5)

        m <- recalc_rwa_from_anomalies(
          extract_dt = extract,
          anomalies_dt = anom,
          haircut = as.numeric(input$haircut2) / 100,
          method = input$method2
        )

        out_dt(m)

        # Export Excel multi-onglets (détails + synthèse)
        wb <- createWorkbook()
        addWorksheet(wb, "details")
        writeDataTable(wb, "details", as.data.frame(m))

        addWorksheet(wb, "synthese")
        sum_dt <- summarise_compare(m)
        writeDataTable(wb, "synthese", as.data.frame(sum_dt))

        out_file <- file.path(tempdir(), "rwa_recalc_compare.xlsx")
        saveWorkbook(wb, out_file, overwrite = TRUE)
        out_path(out_file)

        incProgress(0.9)
        showNotification("Recalcul terminé + fichier Excel généré.", type = "message", duration = 6)
      })
    })

    output$tbl_sum <- renderDT({
      m <- out_dt()
      req(m)
      datatable(summarise_compare(m), options = list(pageLength = 25), rownames = FALSE)
    })

    output$tbl_details <- renderDT({
      m <- out_dt()
      req(m)
      # on affiche un extrait pour l'IHM
      cols <- intersect(c("ID_CONTRAT", "ID_TYPE", "ASOF_DT", "PRTF", "SSPRTF", "EAD", "RWA_retour4c", "RWA_calc_corrige", "Delta_RWA"), names(m))
      show <- m[, ..cols]
      datatable(head(show, 200), options = list(pageLength = 10), rownames = FALSE)
    })

    output$dl_recalc <- downloadHandler(
      filename = function() "rwa_recalc_compare.xlsx",
      content = function(file) {
        req(out_path())
        file.copy(out_path(), file, overwrite = TRUE)
      }
    )
  })
}

##############################
# 9) UI global + Server global
##############################
ui <- page_navbar(
  title = "RWA Bâle - Retour4C & Data Quality",
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  useShinyjs(),

  nav_panel(
    "1) Calcul RWA",
    mod_calc_ui("calc")
  ),

  nav_panel(
    "2) Retour4C (CSV 3Go+)",
    mod_retour4c_ui("retour")
  ),

  nav_panel(
    "3) Anomalies DQ -> Extraction",
    mod_anom_ui("anom")
  ),

  nav_panel(
    "4) Recalcul RWA corrigé",
    mod_recalc_ui("recalc")
  )
)

server <- function(input, output, session) {

  # Module 1 : indépendant
  mod_calc_server("calc")

  # Module 2 : charge Retour4C et expose retour_dt()
  ret <- mod_retour4c_server("retour")

  # Module 3 : utilise Retour4C chargé
  mod_anom_server("anom", retour_dt_r = ret$retour_dt)

  # Module 4 : utilise Retour4C chargé + anomalies
  mod_recalc_server("recalc", retour_dt_r = ret$retour_dt)
}

shinyApp(ui, server)