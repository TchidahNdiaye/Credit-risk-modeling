# ============================================================
#  Application RShiny RWA - Standard & IRBA + Retour4C + DQ
#  Version: renforcement Module 3 (Anomalies -> Extraction)
#           + auto-détection sep/dec + description globale
#           + format FR (milliers + 2 décimales) dans synthèses
#           + gestion d'erreurs "audit-friendly"
# ============================================================

suppressPackageStartupMessages({
  library(shiny)
  library(bslib)
  library(shinyjs)
  library(data.table)
  library(DT)
  library(ggplot2)
  library(readxl)
  library(openxlsx)
})

# -----------------------------
# Utils: gestion d'erreurs
# -----------------------------
fmt_trace <- function() {
  # Traceback lisible pour UI (pas de "line number" garanti en Shiny)
  paste(capture.output(utils::capture.output(traceback())), collapse = "\n")
}

safe_run <- function(action_label, prereq_text, expr) {
  # Encapsule une action: retourne list(ok=TRUE,result=..) ou list(ok=FALSE, user_msg=.., debug=..)
  tryCatch(
    {
      res <- eval.parent(substitute(expr))
      list(ok = TRUE, result = res)
    },
    error = function(e) {
      dbg <- paste0(
        "=== ACTION: ", action_label, " ===\n",
        "ERROR: ", conditionMessage(e), "\n",
        "CALL: ", paste(deparse(conditionCall(e)), collapse = " "), "\n\n",
        "TRACE:\n", paste(capture.output(traceback(2)), collapse = "\n")
      )
      list(
        ok = FALSE,
        user_msg = paste0("Erreur pendant: ", action_label, "\n\n",
                          "Pré-requis / piste de correction:\n- ", prereq_text),
        debug = dbg
      )
    }
  )
}

ui_error_box <- function(id) {
  # Box UI standard pour afficher erreurs + détails techniques
  tagList(
    uiOutput(id)
  )
}

render_error_box <- function(err_rv) {
  renderUI({
    err <- err_rv()
    if (is.null(err)) return(NULL)

    div(
      style = "border:1px solid #d9534f; background:#fff5f5; padding:12px; border-radius:8px; margin-top:10px;",
      tags$b("❌ Erreur"),
      tags$pre(style="white-space:pre-wrap; font-size:12px;", err$user_msg),
      tags$details(
        tags$summary("Détails techniques (trace)"),
        tags$pre(style="white-space:pre-wrap; font-size:11px;", err$debug)
      )
    )
  })
}

# -----------------------------
# Utils: lecture gros fichiers (CSV/TXT)
# Auto-détection sep + heuristique dec
# -----------------------------
detect_sep <- function(path) {
  # Heuristique simple: compter séparateurs dans la première ligne non vide
  ln <- readLines(path, n = 5, warn = FALSE, encoding = "UTF-8")
  ln <- ln[nzchar(ln)]
  if (length(ln) == 0) return(",")
  l1 <- ln[1]

  candidates <- c(";", ",", "\t", "|")
  counts <- sapply(candidates, function(s) stringi::stri_count_fixed(l1, s))
  candidates[which.max(counts)]
}

detect_dec <- function(sep) {
  # Heuristique: en France sep=";" => dec="," souvent. Sinon "."
  if (identical(sep, ";")) "," else "."
}

safe_fread_preview <- function(path) {
  sep <- detect_sep(path)
  dec <- detect_dec(sep)

  dt <- fread(
    file = path,
    sep = sep,
    dec = dec,
    nrows = 5,
    showProgress = FALSE,
    encoding = "UTF-8",
    fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

safe_fread_full <- function(path) {
  sep <- detect_sep(path)
  dec <- detect_dec(sep)

  dt <- fread(
    file = path,
    sep = sep,
    dec = dec,
    showProgress = TRUE,
    encoding = "UTF-8",
    fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

# -----------------------------
# Utils: préparation de données Retour4C
# -----------------------------
to_num_safe <- function(x) {
  # Conversion douce vers numeric (gère virgules/espaces)
  if (is.numeric(x)) return(x)
  x <- as.character(x)
  x <- gsub("\u00A0", " ", x)      # NBSP
  x <- gsub(" ", "", x)           # supprimer espaces
  x <- sub(",", ".", x, fixed=TRUE)
  suppressWarnings(as.numeric(x))
}

normalize_colnames <- function(dt) {
  # Trim + garder noms originaux mais nettoyer les espaces
  setnames(dt, trimws(names(dt)))
  dt
}

prepare_retour4c <- function(dt) {
  dt <- as.data.table(dt)
  dt <- normalize_colnames(dt)

  # Ajout identifiant technique (traçabilité)
  if (!"OBS_ID" %in% names(dt)) dt[, OBS_ID := .I]

  # Colonnes "dimension" attendues (créées si absentes)
  for (cn in c("GoldenSource", "PRTF", "SSPRTF")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_character_]
    dt[is.na(get(cn)) | trimws(get(cn)) == "", (cn) := "UNKNOWN"]
  }

  # Date arrêté
  if (!"ASOF_DT" %in% names(dt)) dt[, ASOF_DT := NA_character_]

  # Création ASOF en Date si possible (multi-formats)
  dt[, ASOF := suppressWarnings(as.IDate(ASOF_DT, format="%Y-%m-%d"))]
  # fallback si format FR
  idx_na <- is.na(dt$ASOF) & !is.na(dt$ASOF_DT)
  if (any(idx_na)) {
    dt[idx_na, ASOF := suppressWarnings(as.IDate(ASOF_DT, format="%d/%m/%Y"))]
  }

  # Montants attendus (créés si absents)
  for (cn in c("Encours", "EAD", "RWA")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_real_]
    dt[, (cn) := to_num_safe(get(cn))]
  }

  # IDs possibles (si présents, on force en character + trim)
  id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
  for (cn in intersect(id_cols, names(dt))) {
    dt[, (cn) := trimws(as.character(get(cn)))]
  }

  dt
}

# -----------------------------
# Utils: canonisation IDs (Module 3)
# -----------------------------
canon_id <- function(x) {
  # Standardise les identifiants pour matching robuste:
  # - character
  # - trim
  # - upper
  # - suppression espaces internes
  # - tentative de conversion si scientific notation "1.23E+10"
  x <- as.character(x)
  x <- trimws(x)
  x <- toupper(x)
  x <- gsub("\\s+", "", x)

  # Si format scientifique, tentative conversion vers string "plein"
  sci <- grepl("^[0-9]+\\.?[0-9]*E[+-]?[0-9]+$", x, ignore.case = TRUE)
  if (any(sci, na.rm = TRUE)) {
    suppressWarnings({
      num <- as.numeric(x[sci])
      # format sans scientifique (attention: précision > 15 digits non garantie si Excel a altéré l'ID)
      x[sci] <- format(num, scientific = FALSE, trim = TRUE, digits = 22)
      x[sci] <- gsub("\\.0$", "", x[sci]) # enlever .0 si entier
      x[sci] <- gsub("\\s+", "", x[sci])
    })
  }

  x
}

# -----------------------------
# Utils: DT format FR (milliers + 2 décimales)
# -----------------------------
datatable_fr <- function(df, digits_cols = NULL) {
  dt <- datatable(df, options = list(pageLength = 10, scrollX = TRUE))
  if (!is.null(digits_cols) && length(digits_cols) > 0) {
    # formatRound gère mark/decMark
    dt <- formatRound(dt, columns = digits_cols, digits = 2, mark = " ", decMark = ",")
  }
  dt
}

# ============================================================
# UI
# ============================================================
ui <- fluidPage(
  useShinyjs(),
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  tags$style(HTML("
    .small-note { font-size: 12px; color: #666; }
  ")),

  titlePanel("Application RShiny RWA - Standard & IRBA | Retour4C | Data Quality"),

  tabsetPanel(
    tabPanel("1) Calcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Paramètres"),
            selectInput("meth", "Méthode", c("Standard", "IRBA")),
            hr(),
            h5("Standard"),
            numericInput("ead_init", "EAD initial", value = 1000000),
            numericInput("ead_corr", "EAD corrigé", value = 1000000),
            numericInput("rw_init", "RW initial (%)", value = 50),
            numericInput("rw_corr", "RW corrigé (%)", value = 45),
            checkboxInput("surete", "Sûreté (Oui/Non)", value = FALSE),
            numericInput("haircut", "Haircut (%)", value = 20, min = 0, max = 100),
            hr(),
            h5("Bilan / Hors-bilan (Standard)"),
            numericInput("ead_b_init", "EAD_B initial", value = 700000),
            numericInput("ead_b_corr", "EAD_B corrigé", value = 700000),
            numericInput("ead_hb_init", "EAD_HB initial", value = 300000),
            numericInput("ead_hb_corr", "EAD_HB corrigé", value = 300000),
            numericInput("ccf_init", "CCF initial (%)", value = 50),
            numericInput("ccf_corr", "CCF corrigé (%)", value = 40),
            hr(),
            h5("IRBA"),
            selectInput("irba_prtf", "PRTF", c("Retail", "Non Retail")),
            selectInput("irba_ssprtf", "SSPRTF (Retail)", c("Immobilier", "Revolving", "Autres")),
            numericInput("pd_init", "PD initial (%)", value = 1),
            numericInput("pd_corr", "PD corrigé (%)", value = 1),
            numericInput("lgd_init", "LGD initial (%)", value = 45),
            numericInput("lgd_corr", "LGD corrigé (%)", value = 45),
            numericInput("m_init", "M initial (années)", value = 2.5),
            numericInput("m_corr", "M corrigé (années)", value = 2.5),
            numericInput("scaling", "Scaling", value = 1.0)
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            verbatimTextOutput("calc_out"),
            plotOutput("calc_plot", height = 300)
          )
        )
      )
    ),

    tabPanel("2) Retour4C",
      fluidRow(
        column(4,
          card(
            card_header("Chargement Retour4C (CSV ou TXT)"),
            fileInput("ret_file", "Choisir Retour4C (.csv/.txt)", accept = c(".csv",".txt")),
            div(class="small-note",
                "Le séparateur et le décimal sont détectés automatiquement (plus de champs sep/dec dans l'IHM)."),
            actionButton("btn_preview", "Afficher preview (5 lignes)"),
            actionButton("btn_load", "Charger complet + préparer"),
            hr(),
            uiOutput("ret_status"),
            ui_error_box("err_mod2")
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            tabsetPanel(
              tabPanel("Preview", DTOutput("ret_preview")),
              tabPanel("Arrêté/Infos", uiOutput("ret_info")),
              tabPanel("Synthèse GoldenSource", DTOutput("syn_gs")),
              tabPanel("Synthèse Portefeuille Bâlois", DTOutput("syn_prtf"))
            )
          )
        )
      )
    ),

    tabPanel("3) Anomalies",
      fluidRow(
        column(4,
          card(
            card_header("Charger anomalies_dq.xlsx"),
            fileInput("ano_file", "Choisir anomalies_dq.xlsx", accept = c(".xlsx")),
            actionButton("btn_ano_preview", "Afficher preview anomalies (5 lignes)"),
            actionButton("btn_extract", "Extraire dans Retour4C"),
            hr(),
            ui_error_box("err_mod3"),
            div(class="small-note",
                "Important: L'extraction nécessite un Retour4C chargé & préparé (Module 2) et au moins 1 colonne ID dans Retour4C.")
          )
        ),
        column(8,
          card(
            card_header("Résultats anomalies"),
            tabsetPanel(
              tabPanel("Preview anomalies", DTOutput("ano_preview")),
              tabPanel("Résultat extraction", DTOutput("ano_extract")),
              tabPanel("Diagnostic matching", verbatimTextOutput("ano_diag")),
              tabPanel("Export",
                downloadButton("dl_extract", "Télécharger ead_rwa_ano_dq.xlsx")
              )
            )
          )
        )
      )
    ),

    tabPanel("4) Recalcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Recalcul & comparaison"),
            selectInput("recalc_meth", "Méthode", c("standard","irba")),
            numericInput("recalc_haircut", "Haircut (%)", value = 20, min = 0, max = 100),
            actionButton("btn_recalc", "Recalculer & comparer"),
            hr(),
            ui_error_box("err_mod4"),
            downloadButton("dl_recalc", "Télécharger rwa_recalc_compare.xlsx")
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            DTOutput("recalc_tbl")
          )
        )
      )
    )
  )
)

# ============================================================
# SERVER
# ============================================================
server <- function(input, output, session) {

  # ---- erreurs par module (reactiveVal)
  err_mod2 <- reactiveVal(NULL)
  err_mod3 <- reactiveVal(NULL)
  err_mod4 <- reactiveVal(NULL)

  output$err_mod2 <- render_error_box(err_mod2)
  output$err_mod3 <- render_error_box(err_mod3)
  output$err_mod4 <- render_error_box(err_mod4)

  # ---- Données réactives
  ret_raw <- reactiveVal(NULL)       # Retour4C brut (après fread full)
  ret_prep <- reactiveVal(NULL)      # Retour4C préparé
  ret_meta <- reactiveVal(list(sep=NULL, dec=NULL, loaded=FALSE))
  ret_preview_rv <- reactiveVal(NULL)

  ano_dt <- reactiveVal(NULL)        # anomalies (dt)
  ano_preview_rv <- reactiveVal(NULL)
  extract_dt <- reactiveVal(NULL)    # extraction résultat
  diag_txt <- reactiveVal("")

  recalc_dt <- reactiveVal(NULL)

  # ---- statut chargement + minuteur simple
  load_start <- reactiveVal(NULL)
  output$ret_status <- renderUI({
    meta <- ret_meta()
    if (isTRUE(meta$loading)) {
      # minuteur
      t0 <- load_start()
      secs <- if (!is.null(t0)) as.integer(difftime(Sys.time(), t0, units="secs")) else 0
      div(
        tags$b("⏳ Fichier en cours de chargement... "),
        tags$span(paste0("(", secs, "s)"))
      )
    } else if (isTRUE(meta$loaded)) {
      div(tags$b("✅ Fichier chargé avec succès."), tags$span(class="small-note", paste0(" sep=", meta$sep, " dec=", meta$dec)))
    } else {
      div(class="small-note", "Aucun fichier chargé.")
    }
  })

  # ============================================================
  # MODULE 1 - Calcul RWA
  # ============================================================
  output$calc_out <- renderPrint({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      rw_i <- input$rw_init/100
      rw_c <- input$rw_corr/100

      # sûreté/haircut appliquée sur EAD
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1

      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c

      # bilan / hors-bilan
      ccf_i <- input$ccf_init/100
      ccf_c <- input$ccf_corr/100

      rwa_b_i <- input$ead_b_init * rw_i
      rwa_b_c <- input$ead_b_corr * rw_c
      rwa_hb_i <- (input$ead_hb_init * ccf_i) * rw_i
      rwa_hb_c <- (input$ead_hb_corr * ccf_c) * rw_c

      list(
        Standard = data.frame(
          RWA_initial = rwa_i,
          RWA_corrige = rwa_c,
          Delta = rwa_c - rwa_i
        ),
        Bilan_HorsBilan = data.frame(
          RWA_B_initial = rwa_b_i,
          RWA_B_corrige = rwa_b_c,
          RWA_HB_initial = rwa_hb_i,
          RWA_HB_corrige = rwa_hb_c,
          RWA_Total_initial = rwa_b_i + rwa_hb_i,
          RWA_Total_corrige = rwa_b_c + rwa_hb_c
        )
      )
    } else {
      # IRBA simplifié (structure; formule complète à brancher dans votre moteur IRB)
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      pd_i <- input$pd_init/100
      pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100
      lgd_c <- input$lgd_corr/100
      sc <- input$scaling

      # "Proxy" K (exemple) : K ≈ PD * LGD (à remplacer par fonction BCBS complète si besoin)
      # Ici on reste simple car votre moteur IRB peut être plus détaillé.
      K_i <- pd_i * lgd_i
      K_c <- pd_c * lgd_c

      rwa_i <- 12.5 * K_i * ead_i * sc
      rwa_c <- 12.5 * K_c * ead_c * sc

      data.frame(RWA_initial = rwa_i, RWA_corrige = rwa_c, Delta = rwa_c - rwa_i)
    }
  })

  output$calc_plot <- renderPlot({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      rw_i <- input$rw_init/100
      rw_c <- input$rw_corr/100
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1
      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c
    } else {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      pd_i <- input$pd_init/100
      pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100
      lgd_c <- input$lgd_corr/100
      sc <- input$scaling
      rwa_i <- 12.5 * (pd_i * lgd_i) * ead_i * sc
      rwa_c <- 12.5 * (pd_c * lgd_c) * ead_c * sc
    }

    df <- data.frame(Type = c("Initial","Corrigé"), RWA = c(rwa_i, rwa_c))
    ggplot(df, aes(x=Type, y=RWA)) + geom_col() + theme_minimal()
  })

  # ============================================================
  # MODULE 2 - Retour4C
  # ============================================================
  observeEvent(input$btn_preview, {
    err_mod2(NULL)
    req(input$ret_file)

    res <- safe_run(
      action_label = "Module 2 / Preview Retour4C",
      prereq_text  = "Sélectionner un fichier Retour4C (.csv ou .txt). Vérifier que le fichier n'est pas vide.",
      expr = {
        pv <- safe_fread_preview(input$ret_file$datapath)
        ret_preview_rv(pv$dt)
        ret_meta(modifyList(ret_meta(), list(sep=pv$sep, dec=pv$dec)))
        pv$dt
      }
    )

    if (!res$ok) err_mod2(res) else invisible(NULL)
  })

  output$ret_preview <- renderDT({
    dt <- ret_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_load, {
    err_mod2(NULL)
    req(input$ret_file)

    ret_meta(modifyList(ret_meta(), list(loading=TRUE, loaded=FALSE)))
    load_start(Sys.time())

    res <- safe_run(
      action_label = "Module 2 / Chargement complet + préparation",
      prereq_text  = paste(
        "1) Le fichier Retour4C doit être accessible (csv/txt).",
        "2) Pour les synthèses: recommander ASOF_DT, GoldenSource, PRTF, Encours, EAD, RWA.",
        "3) Pour extraction anomalies: recommander au moins une colonne ID (SG_CONTRACT_ID ou autre).",
        sep = "\n- "
      ),
      expr = {
        full <- safe_fread_full(input$ret_file$datapath)
        dt_p <- prepare_retour4c(full$dt)

        ret_raw(full$dt)
        ret_prep(dt_p)
        ret_meta(list(sep=full$sep, dec=full$dec, loading=FALSE, loaded=TRUE))

        dt_p
      }
    )

    if (!res$ok) {
      ret_meta(modifyList(ret_meta(), list(loading=FALSE, loaded=FALSE)))
      err_mod2(res)
    }
  })

  # Description globale + arrêté
  output$ret_info <- renderUI({
    dt <- ret_prep()
    if (is.null(dt)) return(div(class="small-note", "Charger Retour4C pour afficher l'arrêté et la description globale."))

    # Arrêté (max ASOF)
    asof_max <- if ("ASOF" %in% names(dt)) dt[, max(ASOF, na.rm=TRUE)] else NA
    asof_max_txt <- if (is.finite(as.numeric(asof_max))) as.character(asof_max) else "NA"

    # Description globale (résumé)
    n <- nrow(dt); p <- ncol(dt)
    mem_mb <- round(as.numeric(object.size(dt)) / 1024^2, 1)

    # Mini data dictionary (sample pour performance)
    smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        v <- x[which(!is.na(x))[1]]
        if (length(v)==0) "" else as.character(v)
      })
    )

    tagList(
      h4("Arrêté"),
      tags$p(tags$b("Arrêté (max ASOF) : "), asof_max_txt),
      hr(),
      h4("Description globale Retour4C"),
      tags$ul(
        tags$li(paste0("Nombre de lignes: ", format(n, big.mark=" ", decimal.mark=","))),
        tags$li(paste0("Nombre de colonnes: ", p)),
        tags$li(paste0("Taille en mémoire (approx): ", mem_mb, " MB")),
        tags$li(paste0("Colonnes principales attendues: ASOF_DT, GoldenSource, PRTF, SSPRTF, Encours, EAD, RWA"))
      ),
      h5("Dictionnaire (échantillon)"),
      DTOutput("ret_dict")
    )
  })

  output$ret_dict <- renderDT({
    dt <- ret_prep()
    req(dt)
    n <- nrow(dt)
    smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        idx <- which(!is.na(x))[1]
        if (is.na(idx)) "" else as.character(x[idx])
      })
    )
    datatable(dict, options = list(scrollX=TRUE, pageLength=10))
  })

  # Synthèses
  compute_syntheses <- reactive({
    dt <- ret_prep()
    req(dt)

    # GoldenSource
    gs <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF, GoldenSource)]

    # Total par ASOF (toutes GS) si besoin, ou TOTAL par GoldenSource (ici: TOTAL global par ASOF)
    gs_total <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF)][, GoldenSource := "TOTAL"][]
    gs_out <- rbind(gs, gs_total, fill=TRUE)

    # Portefeuille
    pr <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF, PRTF)]

    pr_total <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF)][, PRTF := "TOTAL"][]
    pr_out <- rbind(pr, pr_total, fill=TRUE)

    list(gs = gs_out, pr = pr_out)
  })

  output$syn_gs <- renderDT({
    dt <- ret_prep()
    if (is.null(dt)) return(datatable(data.frame()))
    syn <- compute_syntheses()

    # format FR: milliers + 2 décimales
    datatable_fr(
      syn$gs,
      digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR")
    )
  })

  output$syn_prtf <- renderDT({
    dt <- ret_prep()
    if (is.null(dt)) return(datatable(data.frame()))
    syn <- compute_syntheses()

    datatable_fr(
      syn$pr,
      digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR")
    )
  })

  # ============================================================
  # MODULE 3 - Anomalies -> Extraction (RENFORCÉ)
  # ============================================================
  observeEvent(input$btn_ano_preview, {
    err_mod3(NULL)
    req(input$ano_file)

    res <- safe_run(
      action_label = "Module 3 / Preview anomalies",
      prereq_text  = "Sélectionner anomalies_dq.xlsx. La colonne ID_CONTRAT doit exister (ou être renommée/mappée).",
      expr = {
        # IMPORTANT: on force tout en texte pour éviter la conversion Excel -> numeric/scientific
        a <- read_excel(input$ano_file$datapath, col_types = "text")
        a <- as.data.table(a)
        setnames(a, trimws(names(a)))

        # trouver ID_CONTRAT de façon robuste (case-insensitive)
        cn_norm <- toupper(gsub("\\s+", "", names(a)))
        idx <- which(cn_norm == "ID_CONTRAT")
        if (length(idx) == 0) stop("Colonne ID_CONTRAT introuvable dans anomalies_dq.xlsx.")
        setnames(a, names(a)[idx[1]], "ID_CONTRAT")

        # canonisation ID_CONTRAT
        a[, ID_CONTRAT_RAW := ID_CONTRAT]
        a[, ID_CONTRAT_CANON := canon_id(ID_CONTRAT)]

        ano_dt(a)
        ano_preview_rv(head(a, 5))
        a
      }
    )

    if (!res$ok) err_mod3(res)
  })

  output$ano_preview <- renderDT({
    dt <- ano_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_extract, {
    err_mod3(NULL)
    req(ano_dt())
    req(ret_prep())

    res <- safe_run(
      action_label = "Module 3 / Extraction anomalies dans Retour4C",
      prereq_text  = paste(
        "1) Charger Retour4C (Module 2) et exécuter 'Charger complet + préparer'.",
        "2) anomalies_dq.xlsx doit contenir ID_CONTRAT.",
        "3) Retour4C doit contenir au moins une colonne ID parmi:",
        "   SG_CONTRACT_ID, SG_CONTR_BCE, SG_CONTR_3D_ID, SG_FACILITY_ID, SG_ID_ENREGISTRMNT",
        "4) Vérifier que les IDs n'ont pas été altérés par Excel (scientific notation, zéros initiaux).",
        sep = "\n"
      ),
      expr = {
        dt <- copy(ret_prep())
        a  <- copy(ano_dt())

        id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
        present <- intersect(id_cols, names(dt))
        if (length(present) == 0) stop("Aucune colonne ID connue n'est présente dans Retour4C.")

        # Canoniser les colonnes ID dans Retour4C (une seule fois, columns *_CANON)
        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")
          if (!canon_name %in% names(dt)) {
            dt[, (canon_name) := canon_id(get(cn))]
          }
        }

        # Canoniser la liste d'IDs anomalies
        ids <- unique(na.omit(a$ID_CONTRAT_CANON))
        if (length(ids) == 0) stop("Aucun ID_CONTRAT exploitable (vide) dans anomalies.")

        # Diagnostic rapide avant matching
        diag <- list(
          nb_ids_anomalies = length(ids),
          nb_rows_retour4c = nrow(dt),
          id_cols_present  = paste(present, collapse = ", ")
        )

        # Matching robuste par joins successifs (sans melt géant)
        matches <- list()
        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")

          # table anomalies pour join: une colonne qui s'appelle comme canon_name
          aj <- data.table(ID_CONTRAT_CANON = ids)
          setnames(aj, "ID_CONTRAT_CANON", canon_name)

          setkeyv(dt, canon_name)
          setkeyv(aj, canon_name)

          m <- dt[aj, nomatch = 0]
          if (nrow(m) > 0) {
            m[, MATCHED_ON := cn]
            matches[[cn]] <- m
          }
        }

        if (length(matches) == 0) {
          # produire un diagnostic utile
          # montrer quelques ids + exemples de valeurs canonisées dans Retour4C
          ex_ids <- head(ids, 10)
          ex_vals <- lapply(present, function(cn) head(na.omit(dt[[paste0(cn, "_CANON")]]), 10))
          names(ex_vals) <- present

          diag_txt(
            paste0(
              "=== Diagnostic matching ===\n",
              "IDs anomalies (nb unique): ", diag$nb_ids_anomalies, "\n",
              "Rows Retour4C: ", diag$nb_rows_retour4c, "\n",
              "Colonnes ID présentes: ", diag$id_cols_present, "\n\n",
              "Exemples IDs anomalies (canonisés):\n- ", paste(ex_ids, collapse = "\n- "), "\n\n",
              "Exemples valeurs Retour4C (canonisées) par colonne:\n",
              paste(
                sapply(names(ex_vals), function(nm) {
                  paste0("* ", nm, ":\n  - ", paste(ex_vals[[nm]], collapse = "\n  - "))
                }),
                collapse = "\n"
              ), "\n\n",
              "Piste: si Excel a transformé les IDs (scientific), vous risquez une perte de précision.\n",
              "Solution: forcer ID_CONTRAT en texte dans Excel (format Texte) ou utiliser un export CSV."
            )
          )

          extract_dt(data.table())
          return(data.table())
        }

        out <- rbindlist(matches, fill = TRUE)
        # garder une ligne unique par OBS_ID (si match sur plusieurs colonnes)
        setorder(out, OBS_ID)
        out <- unique(out, by = "OBS_ID")

        # Colonnes attendues pour export (si absentes, elles resteront NA)
        keep <- c("ID_CONTRAT_CANON", "ASOF_DT","PRTF","SSPRTF","Segment","PRODUCT_ID","Encours","EAD","RWA",
                  "MATCHED_ON","OBS_ID",
                  "SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
        keep <- intersect(keep, names(out))
        out <- out[, ..keep]

        # rattacher ID_CONTRAT original si possible
        # (optionnel: via join a)
        extract_dt(out)

        diag_txt(
          paste0(
            "=== Diagnostic matching ===\n",
            "IDs anomalies (nb unique): ", diag$nb_ids_anomalies, "\n",
            "Matches: ", nrow(out), "\n",
            "Colonnes ID testées: ", diag$id_cols_present, "\n",
            "Note: MATCHED_ON indique sur quelle colonne l'ID a matché.\n"
          )
        )

        out
      }
    )

    if (!res$ok) err_mod3(res)
  })

  output$ano_extract <- renderDT({
    dt <- extract_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })

  output$ano_diag <- renderPrint({
    cat(diag_txt())
  })

  output$dl_extract <- downloadHandler(
    filename = function() paste0("ead_rwa_ano_dq_", Sys.Date(), ".xlsx"),
    content = function(file) {
      dt <- extract_dt()
      wb <- createWorkbook()
      addWorksheet(wb, "extraction")
      writeDataTable(wb, "extraction", dt)
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )

  # ============================================================
  # MODULE 4 - Recalcul (simple, à adapter à votre moteur exact)
  # ============================================================
  observeEvent(input$btn_recalc, {
    err_mod4(NULL)
    req(ano_dt())
    req(ret_prep())

    res <- safe_run(
      action_label = "Module 4 / Recalcul & comparaison",
      prereq_text  = paste(
        "1) Retour4C chargé & préparé (Module 2).",
        "2) anomalies chargé (Module 3).",
        "3) Pour standard: EAD_corrige/RW_corrige/Surete doivent exister (sinon NA).",
        "4) Pour IRBA: PD_corrige/LGD_corrige/M_corrige doivent exister.",
        sep = "\n"
      ),
      expr = {
        a <- copy(ano_dt())
        dt <- copy(ret_prep())

        # on repart du résultat d'extraction si présent, sinon on refait extraction minimale
        ex <- extract_dt()
        if (is.null(ex) || nrow(ex) == 0) stop("Aucune extraction disponible. Lancer Module 3 -> Extraction d'abord.")

        # joindre anomalies sur extraction par ID canonisé (si anomalies contient aussi canon)
        # (ici, on suppose que la colonne ID_CONTRAT_CANON existe dans anomalies (créée au preview))
        if (!"ID_CONTRAT_CANON" %in% names(a)) stop("Colonne ID_CONTRAT_CANON absente dans anomalies (relancer preview anomalies).")

        # On copie anomalies avec colonnes corrigées si présentes
        corr_cols <- intersect(c("EAD_corrige","RW_corrige","CCF_corrige","Surete","PD_corrige","LGD_corrige","M_corrige","IRB_scaling"), names(a))
        aj <- a[, c("ID_CONTRAT_CANON", corr_cols), with = FALSE]
        setkey(aj, ID_CONTRAT_CANON)
        setkey(ex, ID_CONTRAT_CANON)

        x <- aj[ex]  # left join sur extraction

        hc <- input$recalc_haircut / 100

        if (input$recalc_meth == "standard") {
          # fallback si champs corrigés manquants: utiliser valeurs Retour4C
          # RW_retour4c non disponible => on utilise RWA/EAD si possible
          # Ici on recalcule un RWA corrigé simple: RWA = EAD_corrige * RW_corrige
          x[, EAD_used := fifelse(!is.na(EAD_corrige), to_num_safe(EAD_corrige), EAD)]
          x[, RW_used  := fifelse(!is.na(RW_corrige), to_num_safe(RW_corrige)/100, NA_real_)]

          # Sûreté
          x[, Surete_used := fifelse(!is.na(Surete), as.integer(Surete), 0L)]
          x[, EAD_adj := fifelse(Surete_used == 1L, EAD_used * (1 - hc), EAD_used)]

          x[, RWA_calc_corrige := EAD_adj * RW_used]
        } else {
          # IRBA: proxy
          x[, PD_used  := to_num_safe(PD_corrige)/100]
          x[, LGD_used := to_num_safe(LGD_corrige)/100]
          x[, EAD_used := fifelse(!is.na(EAD_corrige), to_num_safe(EAD_corrige), EAD)]
          x[, sc := fifelse(!is.na(IRB_scaling), to_num_safe(IRB_scaling), 1.0)]
          x[, K := PD_used * LGD_used]
          x[, RWA_calc_corrige := 12.5 * K * EAD_used * sc]
        }

        # comparaison vs Retour4C
        x[, RWA_retour4c := RWA]
        x[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]

        recalc_dt(x)
        x
      }
    )

    if (!res$ok) err_mod4(res)
  })

  output$recalc_tbl <- renderDT({
    dt <- recalc_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })

  output$dl_recalc <- downloadHandler(
    filename = function() paste0("rwa_recalc_compare_", Sys.Date(), ".xlsx"),
    content = function(file) {
      dt <- recalc_dt()
      wb <- createWorkbook()
      addWorksheet(wb, "compare")
      writeDataTable(wb, "compare", dt)
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )

}

shinyApp(ui, server)
