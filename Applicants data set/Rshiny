# ============================================================
#  Application RShiny RWA - Standard & IRBA + Retour4C + DQ
#  Version: Module 2 bouton synthèses
#           + Module 4 recalcul avec 1 seule variable corrigée
# ============================================================

suppressPackageStartupMessages({
  library(shiny)
  library(bslib)
  library(shinyjs)
  library(data.table)
  library(DT)
  library(ggplot2)
  library(readxl)
  library(openxlsx)
})

# -----------------------------
# Utils: gestion d'erreurs
# -----------------------------
safe_run <- function(action_label, prereq_text, expr) {
  tryCatch(
    {
      res <- eval.parent(substitute(expr))
      list(ok = TRUE, result = res)
    },
    error = function(e) {
      dbg <- paste0(
        "=== ACTION: ", action_label, " ===\n",
        "ERROR: ", conditionMessage(e), "\n",
        "CALL: ", paste(deparse(conditionCall(e)), collapse = " "), "\n\n",
        "TRACE:\n", paste(capture.output(traceback(2)), collapse = "\n")
      )
      list(
        ok = FALSE,
        user_msg = paste0("Erreur pendant: ", action_label, "\n\n",
                          "Pré-requis / piste de correction:\n- ", prereq_text),
        debug = dbg
      )
    }
  )
}

render_error_box <- function(err_rv) {
  renderUI({
    err <- err_rv()
    if (is.null(err)) return(NULL)

    div(
      style = "border:1px solid #d9534f; background:#fff5f5; padding:12px; border-radius:8px; margin-top:10px;",
      tags$b("❌ Erreur"),
      tags$pre(style="white-space:pre-wrap; font-size:12px;", err$user_msg),
      tags$details(
        tags$summary("Détails techniques (trace)"),
        tags$pre(style="white-space:pre-wrap; font-size:11px;", err$debug)
      )
    )
  })
}

# -----------------------------
# Utils: lecture gros fichiers (CSV/TXT)
# Auto-détection sep + heuristique dec
# -----------------------------
count_fixed <- function(s, pattern) {
  # compte les occurrences de pattern (string fixe)
  m <- gregexpr(pattern, s, fixed = TRUE)[[1]]
  if (length(m) == 1 && m[1] == -1) return(0L)
  length(m)
}

detect_sep <- function(path) {
  ln <- readLines(path, n = 5, warn = FALSE, encoding = "UTF-8")
  ln <- ln[nzchar(ln)]
  if (length(ln) == 0) return(",")

  l1 <- ln[1]
  candidates <- c(";", ",", "\t", "|")
  counts <- sapply(candidates, function(s) count_fixed(l1, s))
  candidates[which.max(counts)]
}

detect_dec <- function(sep) {
  if (identical(sep, ";")) "," else "."
}

safe_fread_preview <- function(path) {
  sep <- detect_sep(path)
  dec <- detect_dec(sep)

  dt <- fread(
    file = path,
    sep = sep,
    dec = dec,
    nrows = 5,
    showProgress = FALSE,
    encoding = "UTF-8",
    fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

safe_fread_full <- function(path) {
  sep <- detect_sep(path)
  dec <- detect_dec(sep)

  dt <- fread(
    file = path,
    sep = sep,
    dec = dec,
    showProgress = TRUE,
    encoding = "UTF-8",
    fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

# -----------------------------
# Utils: préparation de données Retour4C
# -----------------------------
to_num_safe <- function(x) {
  if (is.numeric(x)) return(x)
  x <- as.character(x)
  x <- gsub("\u00A0", " ", x)      # NBSP
  x <- gsub(" ", "", x)           # supprimer espaces
  x <- sub(",", ".", x, fixed=TRUE)
  suppressWarnings(as.numeric(x))
}

normalize_colnames <- function(dt) {
  setnames(dt, trimws(names(dt)))
  dt
}

prepare_retour4c <- function(dt) {
  dt <- as.data.table(dt)
  dt <- normalize_colnames(dt)

  if (!"OBS_ID" %in% names(dt)) dt[, OBS_ID := .I]

  for (cn in c("GoldenSource", "PRTF", "SSPRTF")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_character_]
    dt[is.na(get(cn)) | trimws(get(cn)) == "", (cn) := "UNKNOWN"]
  }

  if (!"ASOF_DT" %in% names(dt)) dt[, ASOF_DT := NA_character_]

  dt[, ASOF := suppressWarnings(as.IDate(ASOF_DT, format="%Y-%m-%d"))]
  idx_na <- is.na(dt$ASOF) & !is.na(dt$ASOF_DT)
  if (any(idx_na)) {
    dt[idx_na, ASOF := suppressWarnings(as.IDate(ASOF_DT, format="%d/%m/%Y"))]
  }

  for (cn in c("Encours", "EAD", "RWA")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_real_]
    dt[, (cn) := to_num_safe(get(cn))]
  }

  id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
  for (cn in intersect(id_cols, names(dt))) {
    dt[, (cn) := trimws(as.character(get(cn)))]
  }

  dt
}

# -----------------------------
# Utils: canonisation IDs (Module 3)
# -----------------------------
canon_id <- function(x) {
  x <- as.character(x)
  x <- trimws(x)
  x <- toupper(x)
  x <- gsub("\\s+", "", x)

  sci <- grepl("^[0-9]+\\.?[0-9]*E[+-]?[0-9]+$", x, ignore.case = TRUE)
  if (any(sci, na.rm = TRUE)) {
    suppressWarnings({
      num <- as.numeric(x[sci])
      x[sci] <- format(num, scientific = FALSE, trim = TRUE, digits = 22)
      x[sci] <- gsub("\\.0$", "", x[sci])
      x[sci] <- gsub("\\s+", "", x[sci])
    })
  }
  x
}

# -----------------------------
# Utils: DT format FR (milliers + 2 décimales)
# -----------------------------
datatable_fr <- function(df, digits_cols = NULL) {
  dt <- datatable(df, options = list(pageLength = 10, scrollX = TRUE))
  if (!is.null(digits_cols) && length(digits_cols) > 0) {
    dt <- formatRound(dt, columns = digits_cols, digits = 2, mark = " ", decMark = ",")
  }
  dt
}

# ============================================================
# UI
# ============================================================
ui <- fluidPage(
  useShinyjs(),
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  tags$style(HTML(".small-note { font-size: 12px; color: #666; }")),

  titlePanel("Application RShiny RWA - Standard & IRBA | Retour4C | Data Quality"),

  tabsetPanel(
    tabPanel("1) Calcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Paramètres"),
            selectInput("meth", "Méthode", c("Standard", "IRBA")),
            hr(),
            h5("Standard"),
            numericInput("ead_init", "EAD initial", value = 1000000),
            numericInput("ead_corr", "EAD corrigé", value = 1000000),
            numericInput("rw_init", "RW initial (%)", value = 50),
            numericInput("rw_corr", "RW corrigé (%)", value = 45),
            checkboxInput("surete", "Sûreté (Oui/Non)", value = FALSE),
            numericInput("haircut", "Haircut (%)", value = 20, min = 0, max = 100),
            hr(),
            h5("Bilan / Hors-bilan (Standard)"),
            numericInput("ead_b_init", "EAD_B initial", value = 700000),
            numericInput("ead_b_corr", "EAD_B corrigé", value = 700000),
            numericInput("ead_hb_init", "EAD_HB initial", value = 300000),
            numericInput("ead_hb_corr", "EAD_HB corrigé", value = 300000),
            numericInput("ccf_init", "CCF initial (%)", value = 50),
            numericInput("ccf_corr", "CCF corrigé (%)", value = 40),
            hr(),
            h5("IRBA"),
            selectInput("irba_prtf", "PRTF", c("Retail", "Non Retail")),
            selectInput("irba_ssprtf", "SSPRTF (Retail)", c("Immobilier", "Revolving", "Autres")),
            numericInput("pd_init", "PD initial (%)", value = 1),
            numericInput("pd_corr", "PD corrigé (%)", value = 1),
            numericInput("lgd_init", "LGD initial (%)", value = 45),
            numericInput("lgd_corr", "LGD corrigé (%)", value = 45),
            numericInput("m_init", "M initial (années)", value = 2.5),
            numericInput("m_corr", "M corrigé (années)", value = 2.5),
            numericInput("scaling", "Scaling", value = 1.0)
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            verbatimTextOutput("calc_out"),
            plotOutput("calc_plot", height = 300)
          )
        )
      )
    ),

    tabPanel("2) Retour4C",
      fluidRow(
        column(4,
          card(
            card_header("Chargement Retour4C (CSV ou TXT)"),
            fileInput("ret_file", "Choisir Retour4C (.csv/.txt)", accept = c(".csv",".txt")),
            div(class="small-note", "Le séparateur et le décimal sont détectés automatiquement."),
            actionButton("btn_preview", "Afficher preview (5 lignes)"),
            actionButton("btn_load", "Charger complet + préparer"),
            actionButton("btn_syn", "Calculer les synthèses"),
            hr(),
            uiOutput("ret_status"),
            uiOutput("err_mod2")
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            tabsetPanel(
              tabPanel("Preview", DTOutput("ret_preview")),
              tabPanel("Arrêté/Infos", uiOutput("ret_info")),
              tabPanel("Synthèse GoldenSource", DTOutput("syn_gs")),
              tabPanel("Synthèse Portefeuille Bâlois", DTOutput("syn_prtf"))
            )
          )
        )
      )
    ),

    tabPanel("3) Anomalies",
      fluidRow(
        column(4,
          card(
            card_header("Charger anomalies_dq.xlsx"),
            fileInput("ano_file", "Choisir anomalies_dq.xlsx", accept = c(".xlsx")),
            actionButton("btn_ano_preview", "Afficher preview anomalies (5 lignes)"),
            actionButton("btn_extract", "Extraire dans Retour4C"),
            hr(),
            uiOutput("err_mod3"),
            div(class="small-note",
                "Extraction = Retour4C chargé/préparé + anomalies chargées. Retour4C doit contenir au moins une colonne ID.")
          )
        ),
        column(8,
          card(
            card_header("Résultats anomalies"),
            tabsetPanel(
              tabPanel("Preview anomalies", DTOutput("ano_preview")),
              tabPanel("Résultat extraction", DTOutput("ano_extract")),
              tabPanel("Diagnostic matching", verbatimTextOutput("ano_diag")),
              tabPanel("Export", downloadButton("dl_extract", "Télécharger ead_rwa_ano_dq.xlsx"))
            )
          )
        )
      )
    ),

    tabPanel("4) Recalcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Recalcul & comparaison"),
            selectInput("recalc_meth", "Méthode", c("standard","irba")),
            numericInput("recalc_haircut", "Haircut (%)", value = 20, min = 0, max = 100),
            actionButton("btn_recalc", "Recalculer & comparer"),
            hr(),
            uiOutput("err_mod4"),
            downloadButton("dl_recalc", "Télécharger rwa_recalc_compare.xlsx")
          )
        ),
        column(8,
          card(card_header("Résultats"), DTOutput("recalc_tbl"))
        )
      )
    )
  )
)

# ============================================================
# SERVER
# ============================================================
server <- function(input, output, session) {

  # Erreurs par module
  err_mod2_rv <- reactiveVal(NULL)
  err_mod3_rv <- reactiveVal(NULL)
  err_mod4_rv <- reactiveVal(NULL)

  output$err_mod2 <- render_error_box(err_mod2_rv)
  output$err_mod3 <- render_error_box(err_mod3_rv)
  output$err_mod4 <- render_error_box(err_mod4_rv)

  # Données réactives
  ret_raw <- reactiveVal(NULL)
  ret_prep <- reactiveVal(NULL)
  ret_meta <- reactiveVal(list(sep=NULL, dec=NULL, loaded=FALSE, loading=FALSE))
  ret_preview_rv <- reactiveVal(NULL)

  syn_rv <- reactiveVal(NULL)  # ✅ synthèses calculées sur bouton

  ano_dt <- reactiveVal(NULL)
  ano_preview_rv <- reactiveVal(NULL)
  extract_dt <- reactiveVal(NULL)
  diag_txt <- reactiveVal("")

  recalc_dt <- reactiveVal(NULL)

  # statut chargement
  load_start <- reactiveVal(NULL)
  output$ret_status <- renderUI({
    meta <- ret_meta()
    if (isTRUE(meta$loading)) {
      t0 <- load_start()
      secs <- if (!is.null(t0)) as.integer(difftime(Sys.time(), t0, units="secs")) else 0
      div(tags$b("⏳ Fichier en cours de chargement... "), tags$span(paste0("(", secs, "s)")))
    } else if (isTRUE(meta$loaded)) {
      div(tags$b("✅ Fichier chargé avec succès."), tags$span(class="small-note", paste0(" sep=", meta$sep, " dec=", meta$dec)))
    } else {
      div(class="small-note", "Aucun fichier chargé.")
    }
  })

  # -----------------------------
  # MODULE 1 (inchangé)
  # -----------------------------
  output$calc_out <- renderPrint({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      rw_i <- input$rw_init/100
      rw_c <- input$rw_corr/100
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1

      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c

      ccf_i <- input$ccf_init/100
      ccf_c <- input$ccf_corr/100

      rwa_b_i <- input$ead_b_init * rw_i
      rwa_b_c <- input$ead_b_corr * rw_c
      rwa_hb_i <- (input$ead_hb_init * ccf_i) * rw_i
      rwa_hb_c <- (input$ead_hb_corr * ccf_c) * rw_c

      list(
        Standard = data.frame(RWA_initial = rwa_i, RWA_corrige = rwa_c, Delta = rwa_c - rwa_i),
        Bilan_HorsBilan = data.frame(
          RWA_B_initial = rwa_b_i, RWA_B_corrige = rwa_b_c,
          RWA_HB_initial = rwa_hb_i, RWA_HB_corrige = rwa_hb_c,
          RWA_Total_initial = rwa_b_i + rwa_hb_i,
          RWA_Total_corrige = rwa_b_c + rwa_hb_c
        )
      )
    } else {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      pd_i <- input$pd_init/100
      pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100
      lgd_c <- input$lgd_corr/100
      sc <- input$scaling

      K_i <- pd_i * lgd_i
      K_c <- pd_c * lgd_c

      rwa_i <- 12.5 * K_i * ead_i * sc
      rwa_c <- 12.5 * K_c * ead_c * sc

      data.frame(RWA_initial = rwa_i, RWA_corrige = rwa_c, Delta = rwa_c - rwa_i)
    }
  })

  output$calc_plot <- renderPlot({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      rw_i <- input$rw_init/100
      rw_c <- input$rw_corr/100
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1
      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c
    } else {
      ead_i <- input$ead_init
      ead_c <- input$ead_corr
      pd_i <- input$pd_init/100
      pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100
      lgd_c <- input$lgd_corr/100
      sc <- input$scaling
      rwa_i <- 12.5 * (pd_i * lgd_i) * ead_i * sc
      rwa_c <- 12.5 * (pd_c * lgd_c) * ead_c * sc
    }

    df <- data.frame(Type = c("Initial","Corrigé"), RWA = c(rwa_i, rwa_c))
    ggplot(df, aes(x=Type, y=RWA)) + geom_col() + theme_minimal()
  })

  # -----------------------------
  # MODULE 2 - Retour4C
  # -----------------------------
  observeEvent(input$btn_preview, {
    err_mod2_rv(NULL)
    req(input$ret_file)

    res <- safe_run(
      "Module 2 / Preview Retour4C",
      "Sélectionner un fichier Retour4C (.csv ou .txt). Vérifier qu'il n'est pas vide.",
      {
        pv <- safe_fread_preview(input$ret_file$datapath)
        ret_preview_rv(pv$dt)
        ret_meta(modifyList(ret_meta(), list(sep=pv$sep, dec=pv$dec)))
        pv$dt
      }
    )

    if (!res$ok) err_mod2_rv(res)
  })

  output$ret_preview <- renderDT({
    dt <- ret_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_load, {
    err_mod2_rv(NULL)
    req(input$ret_file)

    # reset synthèses à chaque nouveau chargement
    syn_rv(NULL)

    ret_meta(modifyList(ret_meta(), list(loading=TRUE, loaded=FALSE)))
    load_start(Sys.time())

    res <- safe_run(
      "Module 2 / Chargement complet + préparation",
      paste(
        "1) Le fichier Retour4C doit être accessible (csv/txt).",
        "2) Pour les synthèses, recommandé: ASOF_DT, GoldenSource, PRTF, Encours, EAD, RWA.",
        "3) Pour extraction anomalies: au moins 1 colonne ID (SG_CONTRACT_ID, etc.).",
        sep="\n- "
      ),
      {
        full <- safe_fread_full(input$ret_file$datapath)
        dt_p <- prepare_retour4c(full$dt)

        ret_raw(full$dt)
        ret_prep(dt_p)
        ret_meta(list(sep=full$sep, dec=full$dec, loading=FALSE, loaded=TRUE))
        dt_p
      }
    )

    if (!res$ok) {
      ret_meta(modifyList(ret_meta(), list(loading=FALSE, loaded=FALSE)))
      err_mod2_rv(res)
    }
  })

  # Description globale + arrêté
  output$ret_info <- renderUI({
    dt <- ret_prep()
    if (is.null(dt)) return(div(class="small-note", "Charger Retour4C pour afficher l'arrêté et la description globale."))

    asof_max <- if ("ASOF" %in% names(dt)) dt[, suppressWarnings(max(ASOF, na.rm=TRUE))] else NA
    asof_max_txt <- if (!is.na(asof_max)) as.character(asof_max) else "NA"

    n <- nrow(dt); p <- ncol(dt)
    mem_mb <- round(as.numeric(object.size(dt)) / 1024^2, 1)

    smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        idx <- which(!is.na(x))[1]
        if (is.na(idx)) "" else as.character(x[idx])
      })
    )

    tagList(
      h4("Arrêté"),
      tags$p(tags$b("Arrêté (max ASOF) : "), asof_max_txt),
      hr(),
      h4("Description globale Retour4C"),
      tags$ul(
        tags$li(paste0("Nombre de lignes: ", format(n, big.mark=" ", decimal.mark=","))),
        tags$li(paste0("Nombre de colonnes: ", p)),
        tags$li(paste0("Taille en mémoire (approx): ", mem_mb, " MB")),
        tags$li("Colonnes principales recommandées: ASOF_DT, GoldenSource, PRTF, SSPRTF, Encours, EAD, RWA")
      ),
      h5("Dictionnaire (échantillon)"),
      DTOutput("ret_dict")
    )
  })

  output$ret_dict <- renderDT({
    dt <- ret_prep()
    req(dt)
    n <- nrow(dt)
    smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        idx <- which(!is.na(x))[1]
        if (is.na(idx)) "" else as.character(x[idx])
      })
    )
    datatable(dict, options = list(scrollX=TRUE, pageLength=10))
  })

  # Calcul synthèses (fonction)
  compute_syntheses <- function(dt) {
    gs <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF, GoldenSource)]

    gs_total <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF)][, GoldenSource := "TOTAL"][]
    gs_out <- rbind(gs, gs_total, fill=TRUE)

    pr <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF, PRTF)]

    pr_total <- dt[, .(
      Nbre_observations = .N,
      Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
      EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
      RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
    ), by = .(ASOF)][, PRTF := "TOTAL"][]
    pr_out <- rbind(pr, pr_total, fill=TRUE)

    list(gs = gs_out, pr = pr_out)
  }

  # ✅ Bouton "Calculer les synthèses"
  observeEvent(input$btn_syn, {
    err_mod2_rv(NULL)
    req(ret_prep())

    res <- safe_run(
      "Module 2 / Calcul des synthèses",
      "Charger Retour4C puis cliquer 'Charger complet + préparer'. Colonnes recommandées: ASOF_DT, GoldenSource, PRTF, Encours, EAD, RWA.",
      {
        syn <- compute_syntheses(ret_prep())
        syn_rv(syn)
        syn
      }
    )
    if (!res$ok) err_mod2_rv(res)
  })

  output$syn_gs <- renderDT({
    syn <- syn_rv()
    if (is.null(syn)) return(datatable(data.frame()))
    datatable_fr(syn$gs, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
  })

  output$syn_prtf <- renderDT({
    syn <- syn_rv()
    if (is.null(syn)) return(datatable(data.frame()))
    datatable_fr(syn$pr, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
  })

  # -----------------------------
  # MODULE 3 - Anomalies -> Extraction (inchangé vs version précédente renforcée)
  # -----------------------------
  observeEvent(input$btn_ano_preview, {
    err_mod3_rv(NULL)
    req(input$ano_file)

    res <- safe_run(
      "Module 3 / Preview anomalies",
      "Sélectionner anomalies_dq.xlsx. La colonne ID_CONTRAT doit exister.",
      {
        a <- read_excel(input$ano_file$datapath, col_types = "text")
        a <- as.data.table(a)
        setnames(a, trimws(names(a)))

        cn_norm <- toupper(gsub("\\s+", "", names(a)))
        idx <- which(cn_norm == "ID_CONTRAT")
        if (length(idx) == 0) stop("Colonne ID_CONTRAT introuvable dans anomalies_dq.xlsx.")
        setnames(a, names(a)[idx[1]], "ID_CONTRAT")

        a[, ID_CONTRAT_RAW := ID_CONTRAT]
        a[, ID_CONTRAT_CANON := canon_id(ID_CONTRAT)]

        ano_dt(a)
        ano_preview_rv(head(a, 5))
        a
      }
    )
    if (!res$ok) err_mod3_rv(res)
  })

  output$ano_preview <- renderDT({
    dt <- ano_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_extract, {
    err_mod3_rv(NULL)
    req(ano_dt()); req(ret_prep())

    res <- safe_run(
      "Module 3 / Extraction anomalies dans Retour4C",
      paste(
        "1) Charger Retour4C (Module 2) + préparation.",
        "2) anomalies: ID_CONTRAT en texte (pas de scientific).",
        "3) Retour4C: au moins 1 colonne ID: SG_CONTRACT_ID / SG_CONTR_BCE / SG_CONTR_3D_ID / SG_FACILITY_ID / SG_ID_ENREGISTRMNT.",
        sep="\n"
      ),
      {
        dt <- copy(ret_prep())
        a  <- copy(ano_dt())

        id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
        present <- intersect(id_cols, names(dt))
        if (length(present) == 0) stop("Aucune colonne ID connue n'est présente dans Retour4C.")

        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")
          if (!canon_name %in% names(dt)) dt[, (canon_name) := canon_id(get(cn))]
        }

        ids <- unique(na.omit(a$ID_CONTRAT_CANON))
        if (length(ids) == 0) stop("Aucun ID_CONTRAT exploitable dans anomalies.")

        matches <- list()
        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")
          aj <- data.table(ID_CONTRAT_CANON = ids)
          setnames(aj, "ID_CONTRAT_CANON", canon_name)

          setkeyv(dt, canon_name)
          setkeyv(aj, canon_name)

          m <- dt[aj, nomatch = 0]
          if (nrow(m) > 0) {
            m[, MATCHED_ON := cn]
            matches[[cn]] <- m
          }
        }

        if (length(matches) == 0) {
          diag_txt("0 match. Vérifier: (i) Excel a-t-il transformé les IDs ? (ii) espaces/format ; (iii) colonne ID correcte.")
          extract_dt(data.table())
          return(data.table())
        }

        out <- rbindlist(matches, fill = TRUE)
        out <- unique(out, by = "OBS_ID")

        keep <- c("ID_CONTRAT_CANON", "ASOF_DT","PRTF","SSPRTF","Segment","PRODUCT_ID","Encours","EAD","RWA",
                  "MATCHED_ON","OBS_ID",
                  "SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
        keep <- intersect(keep, names(out))
        out <- out[, ..keep]

        extract_dt(out)
        diag_txt(paste0("Matches: ", nrow(out), " | colonnes ID testées: ", paste(present, collapse=", ")))
        out
      }
    )
    if (!res$ok) err_mod3_rv(res)
  })

  output$ano_extract <- renderDT({
    dt <- extract_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })

  output$ano_diag <- renderPrint({ cat(diag_txt()) })

  output$dl_extract <- downloadHandler(
    filename = function() paste0("ead_rwa_ano_dq_", Sys.Date(), ".xlsx"),
    content = function(file) {
      dt <- extract_dt()
      wb <- createWorkbook()
      addWorksheet(wb, "extraction")
      writeDataTable(wb, "extraction", dt)
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )

  # -----------------------------
  # MODULE 4 - Recalcul (✅ 1 variable corrigée suffit)
  # -----------------------------
  observeEvent(input$btn_recalc, {
    err_mod4_rv(NULL)
    req(ano_dt()); req(ret_prep())

    res <- safe_run(
      "Module 4 / Recalcul & comparaison",
      paste(
        "Pré-requis minimal:",
        "1) Avoir une extraction (Module 3) OU relancer Extraction.",
        "2) anomalies doit contenir ID_CONTRAT.",
        "3) Pour recalcul Standard: il suffit d'avoir AU MOINS l'un des champs: RW_corrige OU EAD_corrige.",
        "   - Si RW_corrige absent -> RW sera inféré via RWA/EAD depuis Retour4C (si possible).",
        "   - Si EAD_corrige absent -> EAD de Retour4C sera utilisé.",
        sep="\n"
      ),
      {
        a <- copy(ano_dt())
        ex <- extract_dt()
        if (is.null(ex) || nrow(ex) == 0) stop("Aucune extraction disponible. Lancer Module 3 -> Extraction d'abord.")

        if (!"ID_CONTRAT_CANON" %in% names(a)) stop("ID_CONTRAT_CANON absent dans anomalies. Relancer Preview anomalies.")
        setkey(a, ID_CONTRAT_CANON); setkey(ex, ID_CONTRAT_CANON)

        corr_cols <- intersect(c("EAD_corrige","RW_corrige","CCF_corrige","Surete",
                                 "PD_corrige","LGD_corrige","M_corrige","IRB_scaling"), names(a))
        aj <- a[, c("ID_CONTRAT_CANON", corr_cols), with = FALSE]
        x <- aj[ex]   # join sur extraction

        hc <- input$recalc_haircut / 100

        if (input$recalc_meth == "standard") {

          # 1) EAD utilisée : EAD_corrige si fourni sinon EAD Retour4C
          if (!"EAD" %in% names(x)) x[, EAD := NA_real_]
          x[, EAD_used := fifelse(!is.na(to_num_safe(EAD_corrige)), to_num_safe(EAD_corrige), EAD)]

          # 2) RW utilisé :
          # - si RW_corrige fourni => RW_used = RW_corrige/100
          # - sinon => inférer RW via RWA/EAD (si possible)
          if (!"RWA" %in% names(x)) x[, RWA := NA_real_]
          x[, RW_from_retour4c := fifelse(!is.na(RWA) & !is.na(EAD) & EAD > 0, RWA / EAD, NA_real_)]

          rw_corr_num <- if ("RW_corrige" %in% names(x)) to_num_safe(x$RW_corrige) else rep(NA_real_, nrow(x))
          x[, RW_used := fifelse(!is.na(rw_corr_num), rw_corr_num/100, RW_from_retour4c)]

          # 3) Sûreté (optionnelle)
          surete_num <- if ("Surete" %in% names(x)) suppressWarnings(as.integer(x$Surete)) else rep(0L, nrow(x))
          surete_num[is.na(surete_num)] <- 0L
          x[, Surete_used := surete_num]
          x[, EAD_adj := fifelse(Surete_used == 1L, EAD_used * (1 - hc), EAD_used)]

          # Contrôle minimal pour calculer
          if (all(is.na(x$EAD_adj))) stop("Impossible de calculer: EAD_used est NA partout (ni EAD_corrige ni EAD Retour4C).")
          if (all(is.na(x$RW_used))) stop("Impossible de calculer: RW_used est NA partout (RW_corrige absent et RW non inférable via RWA/EAD).")

          x[, RWA_calc_corrige := EAD_adj * RW_used]

        } else {
          # IRBA (proxy) : nécessite PD/LGD au minimum
          x[, PD_used  := to_num_safe(PD_corrige)/100]
          x[, LGD_used := to_num_safe(LGD_corrige)/100]
          if (!"EAD" %in% names(x)) x[, EAD := NA_real_]
          x[, EAD_used := fifelse(!is.na(to_num_safe(EAD_corrige)), to_num_safe(EAD_corrige), EAD)]
          x[, sc := fifelse(!is.na(to_num_safe(IRB_scaling)), to_num_safe(IRB_scaling), 1.0)]
          x[, K := PD_used * LGD_used]
          if (all(is.na(x$K))) stop("IRBA: PD_corrige/LGD_corrige manquants ou non numériques.")
          x[, RWA_calc_corrige := 12.5 * K * EAD_used * sc]
        }

        x[, RWA_retour4c := RWA]
        x[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]
        recalc_dt(x)
        x
      }
    )

    if (!res$ok) err_mod4_rv(res)
  })

  output$recalc_tbl <- renderDT({
    dt <- recalc_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })

  output$dl_recalc <- downloadHandler(
    filename = function() paste0("rwa_recalc_compare_", Sys.Date(), ".xlsx"),
    content = function(file) {
      dt <- recalc_dt()
      wb <- createWorkbook()
      addWorksheet(wb, "compare")
      writeDataTable(wb, "compare", dt)
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )
}

shinyApp(ui, server)
