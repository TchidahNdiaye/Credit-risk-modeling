# ============================================================
#  APP RSHINY RWA - VERSION STABLE ET MODULAIRE
#  - Installation packages intégrée (bouton + auto-check)
#  - Modules indépendants :
#       M0: Setup & Diagnostics (self-tests)
#       M1: Calcul RWA IHM (Standard + IRBA proxy)
#       M2: Retour4C (preview, chargement, préparation, synthèses)
#       M3: Anomalies (preview, extraction multi-ID)
#       M4: Recalcul RWA DQ (corrections *_corrige optionnelles + synthèses + Top50 + graphes)
#       M5: Estimation RWA sur fichier Excel (Retail/NonRetail + PD/EAD/LGD + maturité calculée)
#  - Messages : progression, succès, erreurs avec prérequis + trace
# ============================================================

options(shiny.maxRequestSize = 1024 * 1024^2) # 1GB upload (ajuste selon besoin)

# ============================================================
# [00] PACKAGES: check/install/load
# ============================================================
required_pkgs <- c(
  "shiny", "bslib", "shinyjs", "data.table", "DT",
  "ggplot2", "readxl", "openxlsx"
)

pkg_missing <- function(pkgs) pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]

install_and_load <- function(pkgs, repos = "https://cloud.r-project.org") {
  miss <- pkg_missing(pkgs)
  if (length(miss) > 0) {
    install.packages(miss, repos = repos, dependencies = TRUE)
  }
  ok <- sapply(pkgs, require, character.only = TRUE)
  invisible(ok)
}

# Charger si possible (sinon l'IHM proposera le bouton d'installation)
suppressWarnings({
  suppressPackageStartupMessages({
    sapply(intersect(required_pkgs, rownames(installed.packages())), require, character.only = TRUE)
  })
})

# ============================================================
# [01] UTILS: conversions, ids, erreurs, status/progress
# ============================================================

# --------- util numeric safe
to_num_safe <- function(x) {
  if (is.numeric(x)) return(x)
  x <- as.character(x)
  x <- gsub("\u00A0", " ", x)  # NBSP
  x <- gsub(" ", "", x)
  x <- sub(",", ".", x, fixed = TRUE)
  suppressWarnings(as.numeric(x))
}

# --------- detect separator/decimal (csv/txt)
.count_fixed <- function(s, pattern) {
  m <- gregexpr(pattern, s, fixed = TRUE)[[1]]
  if (length(m) == 1 && m[1] == -1) return(0L)
  length(m)
}

detect_sep <- function(path) {
  ln <- readLines(path, n = 5, warn = FALSE, encoding = "UTF-8")
  ln <- ln[nzchar(ln)]
  if (length(ln) == 0) return(",")
  l1 <- ln[1]
  candidates <- c(";", ",", "\t", "|")
  counts <- sapply(candidates, function(s) .count_fixed(l1, s))
  candidates[which.max(counts)]
}

detect_dec <- function(sep) {
  # IMPORTANT: dec doit être une chaîne de caractères
  if (identical(sep, ";")) "," else "."
}

safe_fread_preview <- function(path) {
  sep <- detect_sep(path); dec <- detect_dec(sep)
  dt <- data.table::fread(
    path, sep = sep, dec = dec, nrows = 5,
    showProgress = FALSE, encoding = "UTF-8", fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

safe_fread_full <- function(path) {
  sep <- detect_sep(path); dec <- detect_dec(sep)
  dt <- data.table::fread(
    path, sep = sep, dec = dec,
    showProgress = TRUE, encoding = "UTF-8", fill = TRUE
  )
  list(dt = dt, sep = sep, dec = dec)
}

# --------- canonisation ID (Excel scientific, espaces, casse)
canon_id <- function(x) {
  x <- as.character(x)
  x <- trimws(x)
  x <- toupper(x)
  x <- gsub("\\s+", "", x)

  sci <- grepl("^[0-9]+\\.?[0-9]*E[+-]?[0-9]+$", x, ignore.case = TRUE)
  if (any(sci, na.rm = TRUE)) {
    suppressWarnings({
      num <- as.numeric(x[sci])
      x[sci] <- format(num, scientific = FALSE, trim = TRUE, digits = 22)
      x[sci] <- gsub("\\.0$", "", x[sci])
      x[sci] <- gsub("\\s+", "", x[sci])
    })
  }
  x
}

# --------- DT format FR
datatable_fr <- function(df, digits_cols = NULL) {
  dt <- DT::datatable(df, options = list(pageLength = 10, scrollX = TRUE))
  if (!is.null(digits_cols) && length(digits_cols) > 0) {
    dt <- DT::formatRound(dt, columns = digits_cols, digits = 2, mark = " ", decMark = ",")
  }
  dt
}

# --------- erreur wrapper (prérequis + debug)
safe_run <- function(action_label, prereq_text, expr) {
  tryCatch(
    {
      res <- eval.parent(substitute(expr))
      list(ok = TRUE, result = res)
    },
    error = function(e) {
      dbg <- paste0(
        "=== ACTION: ", action_label, " ===\n",
        "ERROR: ", conditionMessage(e), "\n",
        "CALL: ", paste(deparse(conditionCall(e)), collapse = " "), "\n\n",
        "TRACE:\n", paste(capture.output(traceback(2)), collapse = "\n")
      )
      list(
        ok = FALSE,
        user_msg = paste0(
          "Erreur pendant: ", action_label, "\n\n",
          "Pré-requis / piste de correction:\n- ", prereq_text, "\n\n",
          "Détails techniques disponibles ci-dessous."
        ),
        debug = dbg
      )
    }
  )
}

render_error_box <- function(err_rv) {
  shiny::renderUI({
    err <- err_rv()
    if (is.null(err)) return(NULL)
    shiny::div(
      style = "border:1px solid #d9534f;background:#fff5f5;padding:12px;border-radius:8px;margin-top:10px;",
      shiny::tags$b("❌ Erreur"),
      shiny::tags$pre(style="white-space:pre-wrap;font-size:12px;", err$user_msg),
      shiny::tags$details(
        shiny::tags$summary("Détails techniques (trace)"),
        shiny::tags$pre(style="white-space:pre-wrap;font-size:11px;", err$debug)
      )
    )
  })
}

# --------- task status struct
new_task_state <- function() list(running = FALSE, label = "", start = NULL, msg = "", ok = NA)

task_status_ui <- function(task_rv) {
  shiny::renderUI({
    st <- task_rv()
    if (is.null(st) || (isFALSE(st$running) && is.na(st$ok))) {
      return(shiny::div(class = "small-note", "Aucune tâche en cours."))
    }
    secs <- if (!is.null(st$start)) as.integer(difftime(Sys.time(), st$start, units="secs")) else 0L
    if (isTRUE(st$running)) {
      shiny::div(
        shiny::tags$b(paste0("⏳ ", st$label, " ")),
        shiny::tags$span(paste0("(", secs, "s)")),
        shiny::div(class="small-note", st$msg)
      )
    } else if (isTRUE(st$ok)) {
      shiny::div(
        shiny::tags$b(paste0("✅ ", st$label, " - OK ")),
        shiny::tags$span(class="small-note", paste0("(", secs, "s)")),
        shiny::div(class="small-note", st$msg)
      )
    } else {
      shiny::div(
        shiny::tags$b(paste0("❌ ", st$label, " - KO ")),
        shiny::tags$span(class="small-note", paste0("(", secs, "s)")),
        shiny::div(class="small-note", st$msg)
      )
    }
  })
}

run_task <- function(task_rv, err_rv, label, prereq, expr, ok_msg = "Exécution terminée.") {
  err_rv(NULL)
  task_rv(list(running = TRUE, label = label, start = Sys.time(), msg = "Démarrage...", ok = NA))
  out <- withProgress(message = label, value = 0, {
    incProgress(0.05, detail = "Initialisation...")
    res <- safe_run(label, prereq, {
      incProgress(0.20, detail = "Traitement...")
      val <- eval.parent(substitute(expr))
      incProgress(0.90, detail = "Finalisation...")
      val
    })
    incProgress(1.0, detail = "Terminé")
    res
  })

  if (isTRUE(out$ok)) {
    task_rv(list(running = FALSE, label = label, start = task_rv()$start, msg = ok_msg, ok = TRUE))
    showNotification(paste0("✅ ", label, " : OK"), type = "message", duration = 4)
    return(invisible(out$result))
  } else {
    err_rv(out)
    task_rv(list(running = FALSE, label = label, start = task_rv()$start, msg = "Erreur — voir détail.", ok = FALSE))
    showNotification(paste0("❌ ", label, " : Erreur"), type = "error", duration = 6)
    return(invisible(NULL))
  }
}

# ============================================================
# [02] PREPARATION Retour4C
# ============================================================
prepare_retour4c <- function(dt) {
  dt <- data.table::as.data.table(dt)
  data.table::setnames(dt, trimws(names(dt)))

  if (!"OBS_ID" %in% names(dt)) dt[, OBS_ID := .I]

  # colonnes dimension
  for (cn in c("GoldenSource","PRTF","SSPRTF","Segment","PRODUCT_ID")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_character_]
    dt[is.na(get(cn)) | trimws(as.character(get(cn))) == "", (cn) := "UNKNOWN"]
  }

  # arrêté
  if (!"ASOF_DT" %in% names(dt)) dt[, ASOF_DT := NA_character_]
  dt[, ASOF := suppressWarnings(as.IDate(ASOF_DT, format = "%Y-%m-%d"))]
  idx_na <- is.na(dt$ASOF) & !is.na(dt$ASOF_DT)
  if (any(idx_na)) dt[idx_na, ASOF := suppressWarnings(as.IDate(ASOF_DT, format = "%d/%m/%Y"))]

  # montants
  for (cn in c("Encours","EAD","RWA","EAD_B","EAD_HB","CCF","RW","PD","LGD","M","Surete","Default")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA]
  }
  dt[, Encours := to_num_safe(Encours)]
  dt[, EAD     := to_num_safe(EAD)]
  dt[, RWA     := to_num_safe(RWA)]
  dt[, EAD_B   := to_num_safe(EAD_B)]
  dt[, EAD_HB  := to_num_safe(EAD_HB)]
  dt[, CCF     := to_num_safe(CCF)]
  dt[, RW      := to_num_safe(RW)]
  dt[, PD      := to_num_safe(PD)]
  dt[, LGD     := to_num_safe(LGD)]
  dt[, M       := to_num_safe(M)]
  dt[, Surete  := suppressWarnings(as.integer(Surete))]
  dt[, Default := suppressWarnings(as.integer(Default))]

  # IDs possibles
  id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
  for (cn in intersect(id_cols, names(dt))) dt[, (cn) := trimws(as.character(get(cn)))]

  dt
}

compute_syntheses_ret <- function(dt) {
  dt <- data.table::copy(dt)
  for (cn in c("ASOF","GoldenSource","PRTF","Encours","EAD","RWA")) if (!cn %in% names(dt)) dt[, (cn) := NA]
  dt[, Encours := to_num_safe(Encours)]
  dt[, EAD := to_num_safe(EAD)]
  dt[, RWA := to_num_safe(RWA)]

  gs <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF, GoldenSource)]
  gs_total <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF)][, GoldenSource := "TOTAL"][]
  gs_out <- data.table::rbindlist(list(gs, gs_total), fill = TRUE)

  pr <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF, PRTF)]
  pr_total <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF)][, PRTF := "TOTAL"][]
  pr_out <- data.table::rbindlist(list(pr, pr_total), fill = TRUE)

  list(gs = gs_out, pr = pr_out)
}

# ============================================================
# [03] RWA Engine (Standard + IRBA proxy)
# ============================================================

# RW lookup (EXEMPLE) — à remplacer par votre grille réglementaire interne
rw_sa_lookup <- function(PRTF, SSPRTF, Segment, DefaultFlag) {
  PRTF <- toupper(as.character(PRTF))
  SSPRTF <- toupper(as.character(SSPRTF))
  Segment <- toupper(as.character(Segment))
  if (!is.na(DefaultFlag) && DefaultFlag == 1L) return(1.00)
  if (PRTF == "RETAIL") {
    if (SSPRTF == "IMMOBILIER") return(0.35)
    if (SSPRTF == "REVOLVING")  return(0.75)
    return(0.75)
  }
  if (grepl("SME", Segment)) return(0.85)
  1.00
}

apply_corrige_generic <- function(x) {
  x <- data.table::as.data.table(x)
  corr_cols <- grep("_corrige$", names(x), value = TRUE)
  if (length(corr_cols) == 0) return(x)

  for (cc in corr_cols) {
    base <- sub("_corrige$", "", cc)
    if (!base %in% names(x)) next
    # numérique
    if (is.numeric(x[[base]]) || base %in% c("EAD","RWA","Encours","EAD_B","EAD_HB","CCF","RW","PD","LGD","M")) {
      x[, (base) := data.table::fifelse(!is.na(to_num_safe(get(cc))), to_num_safe(get(cc)), get(base))]
    } else {
      x[, (base) := data.table::fifelse(!is.na(get(cc)) & trimws(as.character(get(cc))) != "", as.character(get(cc)), as.character(get(base)))]
    }
  }
  x
}

# ============================================================
# [04] MODULES UI/SERVER (indépendants)
# ============================================================

# ------------------------- M0: Setup/Diagnostics
mod0_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::tagList(
    shiny::card(
      shiny::card_header("Setup: Packages & Diagnostics"),
      shiny::uiOutput(ns("pkg_status")),
      shiny::actionButton(ns("btn_install"), "Installer / Charger les packages requis"),
      shiny::tags$hr(),
      shiny::actionButton(ns("btn_selftest"), "Lancer Self-Test (modules)"),
      shiny::uiOutput(ns("task_status")),
      shiny::uiOutput(ns("err_box")),
      shiny::DTOutput(ns("test_table"))
    )
  )
}

mod0_server <- function(id) {
  shiny::moduleServer(id, function(input, output, session) {
    err_rv <- shiny::reactiveVal(NULL)
    task_rv <- shiny::reactiveVal(new_task_state())
    tests_rv <- shiny::reactiveVal(NULL)

    output$err_box <- render_error_box(err_rv)
    output$task_status <- task_status_ui(task_rv)

    output$pkg_status <- shiny::renderUI({
      miss <- pkg_missing(required_pkgs)
      if (length(miss) == 0) {
        shiny::div(shiny::tags$b("✅ Tous les packages requis sont disponibles."))
      } else {
        shiny::div(
          shiny::tags$b("⚠️ Packages manquants : "),
          shiny::tags$code(paste(miss, collapse = ", ")),
          shiny::div(class="small-note","Cliquer sur 'Installer / Charger' pour installer automatiquement.")
        )
      }
    })

    shiny::observeEvent(input$btn_install, {
      run_task(
        task_rv, err_rv,
        label = "Setup / Installation packages",
        prereq = "Accès internet + droits d'installation R (install.packages).",
        expr = {
          ok <- install_and_load(required_pkgs)
          ok
        },
        ok_msg = "Packages installés/chargés. Vous pouvez utiliser l’application."
      )
      tests_rv(NULL)
    })

    # Self-test : jeux synthétiques couvrant M2/M3/M4/M5
    shiny::observeEvent(input$btn_selftest, {
      run_task(
        task_rv, err_rv,
        label = "Self-Test (fonctionnel)",
        prereq = "Packages chargés. Aucun fichier requis (tests sur données synthétiques).",
        expr = {
          # ---- Synthèse Retour4C
          ret <- data.table::data.table(
            ASOF_DT="2025-12-31",
            GoldenSource=c("GS1","GS1","GS2"),
            PRTF=c("Retail","Non Retail","Retail"),
            SSPRTF=c("Immobilier","Non Retail","Revolving"),
            Segment=c("SME","CORP","SME"),
            Encours=c(100,200,150),
            EAD=c(120,210,160),
            RWA=c(60,210,120),
            SG_CONTRACT_ID=c("0001","0002","0003")
          )
          ret_p <- prepare_retour4c(ret)
          syn <- compute_syntheses_ret(ret_p)

          # ---- Anomalies + extraction
          ano <- data.table::data.table(
            ID_CONTRAT=c("0001","0003"),
            EAD_corrige=c(130,170),
            RW_corrige=c(55,80)
          )
          ano[, ID_CONTRAT_CANON := canon_id(ID_CONTRAT)]
          # simulate extraction
          ret_p[, SG_CONTRACT_ID_CANON := canon_id(SG_CONTRACT_ID)]
          ex <- ret_p[ret_p$SG_CONTRACT_ID_CANON %in% ano$ID_CONTRAT_CANON]
          ex[, ID_CONTRAT_CANON := SG_CONTRACT_ID_CANON]
          stopifnot(nrow(ex) == 2)

          # ---- Recalc logic minimal
          x <- merge(ex, ano, by.x="ID_CONTRAT_CANON", by.y="ID_CONTRAT_CANON", all.x=TRUE)
          x <- apply_corrige_generic(x)
          x[, RW_ratio := ifelse(RW > 2, RW/100, RW)]
          x[, RW_used := RW_ratio]
          x[, RWA_calc_corrige := EAD * RW_used]
          stopifnot(all(!is.na(x$RWA_calc_corrige)))

          # ---- Estimation excel logic (M5) simulate
          est <- data.table::data.table(
            PRTF=c("Retail","Non Retail"),
            SSPRTF=c("Immobilier","Non Retail"),
            Segment=c("SME","CORP"),
            PD=c(1.0,2.0),
            LGD=c(45,40),
            EAD=c(1000,2000),
            DT_START=as.Date(c("2024-01-01","2024-06-01")),
            DT_END=as.Date(c("2026-01-01","2029-06-01"))
          )
          est[, M := as.numeric(difftime(DT_END, DT_START, units="days"))/365.25]
          stopifnot(all(est$M > 0))

          data.table::data.table(
            Test=c("M2 synthèses", "M3 extraction", "M4 recalcul minimal", "M5 maturité"),
            Result=c("OK","OK","OK","OK")
          )
        },
        ok_msg = "Self-Test terminé : OK"
      ) |> (\(res) { tests_rv(res); invisible(NULL) })()
    })

    output$test_table <- DT::renderDT({
      df <- tests_rv()
      if (is.null(df)) return(DT::datatable(data.frame()))
      DT::datatable(df, options = list(pageLength = 10, dom = "t"))
    })
  })
}

# ------------------------- M1: Calcul RWA IHM
mod1_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::fluidRow(
    shiny::column(4,
      shiny::card(
        shiny::card_header("Paramètres"),
        shiny::selectInput(ns("meth"), "Méthode", c("Standard","IRBA (proxy)")),
        shiny::tags$hr(),
        shiny::h5("Entrées"),
        shiny::numericInput(ns("ead_init"), "EAD initial", 1000000),
        shiny::numericInput(ns("ead_corr"), "EAD corrigé", 1000000),
        shiny::numericInput(ns("rw_init"),  "RW initial (%)", 50),
        shiny::numericInput(ns("rw_corr"),  "RW corrigé (%)", 45),
        shiny::checkboxInput(ns("surete"), "Sûreté", FALSE),
        shiny::numericInput(ns("haircut"), "Haircut (%)", 20, min=0, max=100),
        shiny::tags$hr(),
        shiny::h5("Hors-bilan (option)"),
        shiny::numericInput(ns("ead_b"),  "EAD_B", 700000),
        shiny::numericInput(ns("ead_hb"), "EAD_HB", 300000),
        shiny::numericInput(ns("ccf"),    "CCF (%)", 50, min=0, max=100),
        shiny::tags$hr(),
        shiny::h5("IRBA proxy"),
        shiny::numericInput(ns("pd"),  "PD (%)", 1, min=0),
        shiny::numericInput(ns("lgd"), "LGD (%)", 45, min=0, max=100),
        shiny::numericInput(ns("scaling"), "Scaling", 1.0)
      )
    ),
    shiny::column(8,
      shiny::card(
        shiny::card_header("Résultats"),
        shiny::verbatimTextOutput(ns("out")),
        shiny::plotOutput(ns("plot"), height = 300)
      )
    )
  )
}

mod1_server <- function(id) {
  shiny::moduleServer(id, function(input, output, session) {
    output$out <- shiny::renderPrint({
      meth <- input$meth
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1

      if (meth == "Standard") {
        rw_i <- input$rw_init/100
        rw_c <- input$rw_corr/100
        rwa_i <- (input$ead_init * adj) * rw_i
        rwa_c <- (input$ead_corr * adj) * rw_c

        ccf <- input$ccf/100
        rwa_b <- input$ead_b * rw_c
        rwa_hb <- (input$ead_hb * ccf) * rw_c

        list(
          Standard = data.frame(RWA_initial=rwa_i, RWA_corrige=rwa_c, Delta=rwa_c-rwa_i),
          Bilan_HB = data.frame(RWA_Bilan=rwa_b, RWA_HorsBilan=rwa_hb, RWA_Total=rwa_b+rwa_hb)
        )
      } else {
        pd <- input$pd/100
        lgd <- input$lgd/100
        K <- pd * lgd
        rwa_i <- 12.5 * K * input$ead_init * input$scaling
        rwa_c <- 12.5 * K * input$ead_corr * input$scaling
        data.frame(RWA_initial=rwa_i, RWA_corrige=rwa_c, Delta=rwa_c-rwa_i)
      }
    })

    output$plot <- shiny::renderPlot({
      meth <- input$meth
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1

      if (meth == "Standard") {
        rw_i <- input$rw_init/100; rw_c <- input$rw_corr/100
        rwa_i <- (input$ead_init * adj) * rw_i
        rwa_c <- (input$ead_corr * adj) * rw_c
      } else {
        pd <- input$pd/100; lgd <- input$lgd/100
        K <- pd * lgd
        rwa_i <- 12.5 * K * input$ead_init * input$scaling
        rwa_c <- 12.5 * K * input$ead_corr * input$scaling
      }

      df <- data.frame(Type=c("Initial","Corrigé"), RWA=c(rwa_i, rwa_c))
      ggplot2::ggplot(df, ggplot2::aes(x=Type, y=RWA)) + ggplot2::geom_col() + ggplot2::theme_minimal()
    })
  })
}

# ------------------------- M2: Retour4C
mod2_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::fluidRow(
    shiny::column(4,
      shiny::card(
        shiny::card_header("Retour4C (CSV/TXT)"),
        shiny::fileInput(ns("file"), "Choisir Retour4C (.csv/.txt)", accept = c(".csv",".txt")),
        shiny::actionButton(ns("btn_preview"), "Afficher preview (5 lignes)"),
        shiny::actionButton(ns("btn_load"), "Charger complet + préparer"),
        shiny::actionButton(ns("btn_syn"), "Calculer / Recalculer synthèses"),
        shiny::div(class="status-box", shiny::uiOutput(ns("task_status"))),
        shiny::uiOutput(ns("err_box"))
      )
    ),
    shiny::column(8,
      shiny::card(
        shiny::card_header("Résultats"),
        shiny::tabsetPanel(
          shiny::tabPanel("Preview", DT::DTOutput(ns("preview"))),
          shiny::tabPanel("Arrêté/Infos", shiny::uiOutput(ns("info"))),
          shiny::tabPanel("Synthèse GoldenSource", shiny::uiOutput(ns("syn_note")), DT::DTOutput(ns("syn_gs"))),
          shiny::tabPanel("Synthèse Portefeuille", shiny::uiOutput(ns("syn_note2")), DT::DTOutput(ns("syn_prtf")))
        )
      )
    )
  )
}

mod2_server <- function(id, shared) {
  shiny::moduleServer(id, function(input, output, session) {
    err_rv <- shiny::reactiveVal(NULL)
    task_rv <- shiny::reactiveVal(new_task_state())

    output$err_box <- render_error_box(err_rv)
    output$task_status <- task_status_ui(task_rv)

    syn_ts <- shiny::reactiveVal(NULL)
    preview_rv <- shiny::reactiveVal(NULL)

    shiny::observeEvent(input$btn_preview, {
      req(input$file)
      run_task(task_rv, err_rv,
        label = "M2 / Preview Retour4C",
        prereq = "Sélectionner un fichier Retour4C (.csv/.txt).",
        expr = {
          pv <- safe_fread_preview(input$file$datapath)
          preview_rv(pv$dt)
          shared$ret_meta(list(sep=pv$sep, dec=pv$dec))
          pv$dt
        },
        ok_msg = "Preview affiché."
      )
    })

    output$preview <- DT::renderDT({
      dt <- preview_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      DT::datatable(dt, options = list(scrollX=TRUE, pageLength=5))
    })

    shiny::observeEvent(input$btn_load, {
      req(input$file)
      run_task(task_rv, err_rv,
        label = "M2 / Charger + préparer",
        prereq = "Fichier Retour4C lisible. Pour synthèses: ASOF_DT, GoldenSource, PRTF, Encours, EAD, RWA recommandés.",
        expr = {
          full <- safe_fread_full(input$file$datapath)
          dt_p <- prepare_retour4c(full$dt)
          shared$ret_prep(dt_p)
          shared$ret_meta(list(sep=full$sep, dec=full$dec))
          syn <- compute_syntheses_ret(dt_p)
          shared$ret_syn(syn)
          syn_ts(Sys.time())
          TRUE
        },
        ok_msg = "Chargement OK + synthèses calculées."
      )
    })

    shiny::observeEvent(input$btn_syn, {
      req(shared$ret_prep())
      run_task(task_rv, err_rv,
        label = "M2 / Recalcul synthèses",
        prereq = "Charger Retour4C via 'Charger complet + préparer'.",
        expr = {
          syn <- compute_syntheses_ret(shared$ret_prep())
          shared$ret_syn(syn)
          syn_ts(Sys.time())
          TRUE
        },
        ok_msg = "Synthèses recalculées."
      )
    })

    output$syn_note <- shiny::renderUI({
      syn <- shared$ret_syn()
      if (is.null(syn)) return(shiny::div(class="small-note","Synthèses non disponibles."))
      shiny::div(class="small-note", paste0("Dernier calcul: ", format(syn_ts(), "%Y-%m-%d %H:%M:%S")))
    })
    output$syn_note2 <- output$syn_note

    output$syn_gs <- DT::renderDT({
      syn <- shared$ret_syn()
      if (is.null(syn)) return(DT::datatable(data.frame()))
      datatable_fr(syn$gs, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
    })

    output$syn_prtf <- DT::renderDT({
      syn <- shared$ret_syn()
      if (is.null(syn)) return(DT::datatable(data.frame()))
      datatable_fr(syn$pr, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
    })

    output$info <- shiny::renderUI({
      dt <- shared$ret_prep()
      if (is.null(dt)) return(shiny::div(class="small-note","Charger Retour4C pour afficher l'arrêté et infos globales."))
      asof_max <- dt[, suppressWarnings(max(ASOF, na.rm=TRUE))]
      asof_txt <- if (!is.na(asof_max)) as.character(asof_max) else "NA"

      n <- nrow(dt); p <- ncol(dt)
      mem_mb <- round(as.numeric(object.size(dt))/1024^2, 1)

      shiny::tagList(
        shiny::h4("Arrêté"),
        shiny::p(shiny::tags$b("Arrêté (max ASOF) : "), asof_txt),
        shiny::tags$hr(),
        shiny::h4("Description globale"),
        shiny::tags$ul(
          shiny::tags$li(paste0("Lignes : ", format(n, big.mark=" "))),
          shiny::tags$li(paste0("Colonnes : ", p)),
          shiny::tags$li(paste0("Taille mémoire approx : ", mem_mb, " MB"))
        )
      )
    })
  })
}

# ------------------------- M3: Anomalies
mod3_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::fluidRow(
    shiny::column(4,
      shiny::card(
        shiny::card_header("Anomalies DQ (Excel)"),
        shiny::fileInput(ns("file"), "Choisir anomalies_dq.xlsx", accept = c(".xlsx")),
        shiny::actionButton(ns("btn_preview"), "Afficher preview anomalies (5 lignes)"),
        shiny::actionButton(ns("btn_extract"), "Extraire dans Retour4C"),
        shiny::div(class="status-box", shiny::uiOutput(ns("task_status"))),
        shiny::uiOutput(ns("err_box"))
      )
    ),
    shiny::column(8,
      shiny::card(
        shiny::card_header("Résultats"),
        shiny::tabsetPanel(
          shiny::tabPanel("Preview anomalies", DT::DTOutput(ns("preview"))),
          shiny::tabPanel("Extraction", DT::DTOutput(ns("extract"))),
          shiny::tabPanel("Diagnostic", shiny::verbatimTextOutput(ns("diag"))),
          shiny::tabPanel("Export", shiny::downloadButton(ns("dl_extract"), "Télécharger ead_rwa_ano_dq.xlsx"))
        )
      )
    )
  )
}

mod3_server <- function(id, shared) {
  shiny::moduleServer(id, function(input, output, session) {
    err_rv <- shiny::reactiveVal(NULL)
    task_rv <- shiny::reactiveVal(new_task_state())
    diag_rv <- shiny::reactiveVal("")
    preview_rv <- shiny::reactiveVal(NULL)

    output$err_box <- render_error_box(err_rv)
    output$task_status <- task_status_ui(task_rv)

    shiny::observeEvent(input$btn_preview, {
      req(input$file)
      run_task(task_rv, err_rv,
        label = "M3 / Preview anomalies",
        prereq = "Le fichier Excel doit contenir la colonne ID_CONTRAT (format texte recommandé).",
        expr = {
          a <- readxl::read_excel(input$file$datapath, col_types = "text")
          a <- data.table::as.data.table(a)
          data.table::setnames(a, trimws(names(a)))

          cn_norm <- toupper(gsub("\\s+", "", names(a)))
          idx <- which(cn_norm == "ID_CONTRAT")
          if (length(idx) == 0) stop("Colonne ID_CONTRAT introuvable.")
          data.table::setnames(a, names(a)[idx[1]], "ID_CONTRAT")

          a[, ID_CONTRAT_CANON := canon_id(ID_CONTRAT)]
          shared$ano_dt(a)
          preview_rv(head(a, 5))
          TRUE
        },
        ok_msg = "Preview anomalies affiché."
      )
    })

    output$preview <- DT::renderDT({
      dt <- preview_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      DT::datatable(dt, options = list(scrollX=TRUE, pageLength=5))
    })

    shiny::observeEvent(input$btn_extract, {
      req(shared$ret_prep())
      req(shared$ano_dt())

      run_task(task_rv, err_rv,
        label = "M3 / Extraction",
        prereq = paste(
          "1) Charger Retour4C (Module 2).",
          "2) Charger anomalies (Module 3 preview).",
          "3) Retour4C doit contenir au moins une colonne ID parmi :",
          "   SG_CONTRACT_ID, SG_CONTR_BCE, SG_CONTR_3D_ID, SG_FACILITY_ID, SG_ID_ENREGISTRMNT",
          sep = "\n"
        ),
        expr = {
          dt <- data.table::copy(shared$ret_prep())
          a  <- data.table::copy(shared$ano_dt())

          id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
          present <- intersect(id_cols, names(dt))
          if (length(present) == 0) stop("Aucune colonne ID connue présente dans Retour4C.")

          # canonisation IDs côté Retour4C (une fois)
          for (cn in present) {
            canon_cn <- paste0(cn, "_CANON")
            if (!canon_cn %in% names(dt)) dt[, (canon_cn) := canon_id(get(cn))]
          }

          ids <- unique(na.omit(a$ID_CONTRAT_CANON))
          if (length(ids) == 0) stop("Aucun ID_CONTRAT exploitable (après canonisation).")

          # matching multi-colonnes
          matches <- list()
          for (cn in present) {
            canon_cn <- paste0(cn, "_CANON")
            m <- dt[get(canon_cn) %in% ids]
            if (nrow(m) > 0) {
              m[, MATCHED_ON := cn]
              m[, ID_CONTRAT_CANON := get(canon_cn)]
              matches[[cn]] <- m
            }
          }

          if (length(matches) == 0) {
            shared$extract_dt(data.table::data.table())
            diag_rv("0 correspondance. Causes fréquentes : scientific Excel, zéros initiaux, espaces, ID pas dans les colonnes testées.")
            return(TRUE)
          }

          out <- data.table::rbindlist(matches, fill = TRUE)
          out <- unique(out, by = "OBS_ID")

          keep <- intersect(c(
            "GoldenSource",
            "ID_CONTRAT_CANON","ASOF_DT","ASOF","PRTF","SSPRTF","Segment","PRODUCT_ID",
            "Encours","EAD","RWA","EAD_B","EAD_HB","CCF","RW","PD","LGD","M","Surete","Default",
            "MATCHED_ON","OBS_ID",
            "SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT"
          ), names(out))
          out <- out[, ..keep]

          shared$extract_dt(out)
          diag_rv(paste0("Matches: ", nrow(out), " | IDs testées: ", paste(present, collapse=", ")))
          TRUE
        },
        ok_msg = "Extraction terminée."
      )
    })

    output$extract <- DT::renderDT({
      dt <- shared$extract_dt()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      DT::datatable(dt, options = list(scrollX=TRUE, pageLength=10))
    })

    output$diag <- shiny::renderPrint({ cat(diag_rv()) })

    output$dl_extract <- shiny::downloadHandler(
      filename = function() paste0("ead_rwa_ano_dq_", Sys.Date(), ".xlsx"),
      content = function(file) {
        wb <- openxlsx::createWorkbook()
        openxlsx::addWorksheet(wb, "extraction")
        openxlsx::writeDataTable(wb, "extraction", shared$extract_dt())
        openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
      }
    )
  })
}

# ------------------------- M4: Recalcul DQ + Top50 + graphs
mod4_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::fluidRow(
    shiny::column(4,
      shiny::card(
        shiny::card_header("Recalcul RWA (DQ optionnel)"),
        shiny::selectInput(ns("meth"), "Méthode", c("standard","irba_proxy")),
        shiny::numericInput(ns("haircut"), "Haircut (%) si Surete=1", 20, min=0, max=100),
        shiny::checkboxInput(ns("use_rw_lookup"), "Utiliser grille RW interne si RW absent", TRUE),
        shiny::actionButton(ns("btn_recalc"), "Recalculer & comparer"),
        shiny::div(class="status-box", shiny::uiOutput(ns("task_status"))),
        shiny::uiOutput(ns("err_box")),
        shiny::tags$hr(),
        shiny::downloadButton(ns("dl"), "Télécharger rwa_recalc_compare.xlsx")
      )
    ),
    shiny::column(8,
      shiny::card(
        shiny::card_header("Résultats"),
        shiny::tabsetPanel(
          shiny::tabPanel("Détail", DT::DTOutput(ns("detail"))),
          shiny::tabPanel("Synthèse impacts",
            shiny::h5("Par PRTF/SSPRTF"), DT::DTOutput(ns("syn_prtf")),
            shiny::tags$hr(),
            shiny::h5("Par GoldenSource"), DT::DTOutput(ns("syn_gs"))
          ),
          shiny::tabPanel("Qualité corrections (_corrige)", DT::DTOutput(ns("corr_stats"))),
          shiny::tabPanel("Top 50 & Graphiques",
            shiny::tabsetPanel(
              shiny::tabPanel("Top50 |ΔRWA|", DT::DTOutput(ns("t_abs")), shiny::plotOutput(ns("p_abs"), height=320)),
              shiny::tabPanel("Top50 ΔRWA positif", DT::DTOutput(ns("t_pos")), shiny::plotOutput(ns("p_pos"), height=320)),
              shiny::tabPanel("Top50 ΔRWA négatif", DT::DTOutput(ns("t_neg")), shiny::plotOutput(ns("p_neg"), height=320)),
              shiny::tabPanel("Top50 RWA corrigé", DT::DTOutput(ns("t_rwa")), shiny::plotOutput(ns("p_rwa"), height=320))
            )
          )
        )
      )
    )
  )
}

mod4_server <- function(id, shared) {
  shiny::moduleServer(id, function(input, output, session) {
    err_rv <- shiny::reactiveVal(NULL)
    task_rv <- shiny::reactiveVal(new_task_state())
    output$err_box <- render_error_box(err_rv)
    output$task_status <- task_status_ui(task_rv)

    recalc_rv <- shiny::reactiveVal(NULL)
    syn_prtf_rv <- shiny::reactiveVal(NULL)
    syn_gs_rv <- shiny::reactiveVal(NULL)
    corr_stats_rv <- shiny::reactiveVal(NULL)
    top_abs <- shiny::reactiveVal(NULL)
    top_pos <- shiny::reactiveVal(NULL)
    top_neg <- shiny::reactiveVal(NULL)
    top_rwa <- shiny::reactiveVal(NULL)

    compute_recalc_summaries <- function(x) {
      x <- data.table::copy(x)
      syn_prtf <- x[, .(
        Nbre_observations = .N,
        RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
        RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
        Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
      ), by = .(PRTF, SSPRTF)]
      syn_prtf <- data.table::rbindlist(list(
        syn_prtf,
        x[, .(
          Nbre_observations = .N,
          RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
          RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
          Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
        )][, `:=`(PRTF="TOTAL", SSPRTF="TOTAL")]
      ), fill=TRUE)

      syn_gs <- x[, .(
        Nbre_observations = .N,
        RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
        RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
        Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
      ), by = .(GoldenSource)]
      syn_gs <- data.table::rbindlist(list(
        syn_gs,
        x[, .(
          Nbre_observations = .N,
          RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
          RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
          Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
        )][, GoldenSource:="TOTAL"]
      ), fill=TRUE)

      list(syn_prtf=syn_prtf, syn_gs=syn_gs)
    }

    compute_corr_stats <- function(a) {
      a <- data.table::copy(a)
      corr_cols <- grep("_corrige$", names(a), value = TRUE)
      if (length(corr_cols) == 0) {
        return(data.table::data.table(variable_corrige=character(), pct_remplissage=numeric(), nb_lignes_remplies=integer(), exemple=character()))
      }
      stats <- data.table::rbindlist(lapply(corr_cols, function(cc) {
        v <- a[[cc]]
        filled <- !is.na(v) & trimws(as.character(v)) != ""
        data.table::data.table(
          variable_corrige = cc,
          pct_remplissage = round(100 * mean(filled), 2),
          nb_lignes_remplies = sum(filled),
          exemple = { idx <- which(filled)[1]; if (length(idx)==0) "" else as.character(v[idx]) }
        )
      }), fill=TRUE)
      stats[order(-nb_lignes_remplies, variable_corrige)]
    }

    compute_tops <- function(x) {
      tt <- data.table::copy(x)
      tt[, abs_delta := abs(Delta_RWA)]
      tt_abs <- tt[!is.na(abs_delta)][order(-abs_delta)]
      tt_pos <- tt[!is.na(Delta_RWA) & Delta_RWA > 0][order(-Delta_RWA)]
      tt_neg <- tt[!is.na(Delta_RWA) & Delta_RWA < 0][order(Delta_RWA)]
      tt_rwa <- tt[!is.na(RWA_calc_corrige)][order(-RWA_calc_corrige)]

      keep <- intersect(c(
        "ID_CONTRAT","ID_CONTRAT_CANON","GoldenSource","PRTF","SSPRTF","Segment","PRODUCT_ID","ASOF_DT","MATCHED_ON",
        "EAD_eff","EAD_adj","RW_used","RWA_retour4c","RWA_calc_corrige","Delta_RWA","corrections_appliquees","calc_flag","calc_msg"
      ), names(tt))

      list(
        abs = head(tt_abs[, ..keep], 50),
        pos = head(tt_pos[, ..keep], 50),
        neg = head(tt_neg[, ..keep], 50),
        rwa = head(tt_rwa[, ..keep], 50)
      )
    }

    plot_top <- function(dt, y_col, y_lab) {
      if (is.null(dt) || nrow(dt)==0) return(NULL)
      d <- data.table::copy(dt)
      d[, y := get(y_col)/1e6]
      d[, id_bar := if ("ID_CONTRAT" %in% names(d)) as.character(ID_CONTRAT) else as.character(ID_CONTRAT_CANON)]
      d <- d[!is.na(y)]
      if (nrow(d)==0) return(NULL)
      ggplot2::ggplot(d, ggplot2::aes(x=reorder(id_bar, y), y=y)) +
        ggplot2::geom_col() +
        ggplot2::coord_flip() +
        ggplot2::theme_minimal() +
        ggplot2::labs(x="ID_CONTRAT", y=y_lab)
    }

    shiny::observeEvent(input$btn_recalc, {
      run_task(task_rv, err_rv,
        label = "M4 / Recalcul & comparaison",
        prereq = paste(
          "1) Module 2: Retour4C chargé et préparé.",
          "2) Module 3: anomalies preview + extraction (matches > 0).",
          "3) anomalies peut contenir 1 seule variable *_corrige (EAD_corrige ou RW_corrige etc.).",
          sep="\n"
        ),
        expr = {
          ex <- shared$extract_dt()
          a  <- shared$ano_dt()
          if (is.null(ex) || nrow(ex)==0) stop("Extraction vide. Lancer Module 3 -> Extraction.")
          if (is.null(a)  || nrow(a)==0)  stop("Anomalies non chargées. Lancer Module 3 -> Preview anomalies.")

          # joindre anomalies -> extraction via ID_CONTRAT_CANON
          if (!"ID_CONTRAT_CANON" %in% names(a)) stop("ID_CONTRAT_CANON absent (relancer preview anomalies).")
          x <- merge(ex, a, by.x="ID_CONTRAT_CANON", by.y="ID_CONTRAT_CANON", all.x=TRUE, suffixes=c("", "_ano"))

          # identifier ID_CONTRAT original si présent
          if ("ID_CONTRAT" %in% names(x)) x[, ID_CONTRAT := as.character(ID_CONTRAT)]
          if (!"ID_CONTRAT" %in% names(x) && "ID_CONTRAT_ano" %in% names(x)) x[, ID_CONTRAT := as.character(ID_CONTRAT_ano)]

          # tracer corrections appliquées
          corr_cols <- grep("_corrige$", names(x), value=TRUE)
          x[, corrections_appliquees := ""]
          if (length(corr_cols) > 0) {
            x[, corrections_appliquees := {
              filled <- corr_cols[ sapply(.SD, function(v) any(!is.na(v) & trimws(as.character(v))!="")) ]
              paste(filled, collapse=";")
            }, .SDcols = corr_cols, by = .I]
          }

          # appliquer corrections
          x <- apply_corrige_generic(x)

          # EAD effectif
          x[, CCF := ifelse(is.na(CCF), 1, CCF)]
          x[, EAD_eff := if (!all(is.na(EAD_B)) || !all(is.na(EAD_HB))) {
            ead_b  <- ifelse(is.na(EAD_B), 0, EAD_B)
            ead_hb <- ifelse(is.na(EAD_HB), 0, EAD_HB)
            ead_b + (ead_hb * CCF)
          } else {
            EAD
          }]

          # surete (corrige si présent)
          surete_used <- if ("Surete_corrige" %in% names(x)) suppressWarnings(as.integer(x$Surete_corrige))
          else if ("Surete" %in% names(x)) suppressWarnings(as.integer(x$Surete))
          else rep(0L, nrow(x))
          surete_used[is.na(surete_used)] <- 0L
          x[, Surete_used := surete_used]

          hc <- input$haircut/100
          x[, EAD_adj := ifelse(Surete_used==1L, EAD_eff*(1-hc), EAD_eff)]

          # RW_used cascade
          x[, RW_ratio := {
            rw <- to_num_safe(RW)
            ifelse(!is.na(rw) & rw > 2, rw/100, rw)
          }]
          x[, RW_from_ret := ifelse(!is.na(RWA) & !is.na(EAD_eff) & EAD_eff>0, RWA/EAD_eff, NA_real_)]

          rw_corr <- NA_real_
          if ("RW_corrige" %in% names(x)) {
            tmp <- to_num_safe(x$RW_corrige)
            rw_corr <- ifelse(!is.na(tmp) & tmp > 2, tmp/100, tmp)
          }

          default_used <- if ("Default_corrige" %in% names(x)) suppressWarnings(as.integer(x$Default_corrige))
          else if ("Default" %in% names(x)) suppressWarnings(as.integer(x$Default))
          else rep(0L, nrow(x))
          default_used[is.na(default_used)] <- 0L
          x[, Default_used := default_used]

          x[, RW_used := {
            if (!is.na(rw_corr)) rw_corr
            else if (!is.na(RW_ratio)) RW_ratio
            else if (!is.na(RW_from_ret)) RW_from_ret
            else if (isTRUE(input$use_rw_lookup)) mapply(rw_sa_lookup, PRTF, SSPRTF, Segment, Default_used)
            else NA_real_
          }]

          # calcul RWA corrigé
          if (input$meth == "standard") {
            x[, RWA_calc_corrige := EAD_adj * RW_used]
          } else {
            # IRBA proxy : 12.5*(PD*LGD)*EAD_adj
            pd <- if ("PD_corrige" %in% names(x)) to_num_safe(x$PD_corrige)/100 else to_num_safe(x$PD)/100
            lgd<- if ("LGD_corrige" %in% names(x)) to_num_safe(x$LGD_corrige)/100 else to_num_safe(x$LGD)/100
            sc <- if ("IRB_scaling" %in% names(x)) to_num_safe(x$IRB_scaling) else 1.0
            x[, K := pd*lgd]
            x[, RWA_calc_corrige := 12.5 * K * EAD_adj * sc]
          }

          x[, RWA_retour4c := RWA]
          x[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]
          x[, calc_flag := ifelse(is.na(RWA_calc_corrige), "KO", "OK")]
          x[, calc_msg := ""]
          x[calc_flag=="KO" & input$meth=="standard", calc_msg := "RW indisponible: fournir RW_corrige ou RW, ou activer la grille RW."]
          x[calc_flag=="KO" & input$meth!="standard", calc_msg := "IRBA proxy: PD/LGD manquants/non numériques."]

          # sortie
          keep <- intersect(c(
            "GoldenSource","ID_CONTRAT","ID_CONTRAT_CANON","MATCHED_ON","ASOF_DT","PRTF","SSPRTF","Segment","PRODUCT_ID",
            "Encours","EAD","EAD_B","EAD_HB","CCF","EAD_eff","EAD_adj",
            "RW","RW_ratio","RW_from_ret","RW_used",
            "Surete_used","Default_used",
            "RWA_retour4c","RWA_calc_corrige","Delta_RWA",
            "corrections_appliquees","calc_flag","calc_msg"
          ), names(x))
          x_out <- x[, ..keep]

          recalc_rv(x_out)
          syn <- compute_recalc_summaries(x_out)
          syn_prtf_rv(syn$syn_prtf)
          syn_gs_rv(syn$syn_gs)
          corr_stats_rv(compute_corr_stats(a))

          tops <- compute_tops(x_out)
          top_abs(tops$abs); top_pos(tops$pos); top_neg(tops$neg); top_rwa(tops$rwa)

          TRUE
        },
        ok_msg = "Recalcul OK. Synthèses + Top50 générés."
      )
    })

    output$detail <- DT::renderDT({
      dt <- recalc_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      DT::datatable(dt, options = list(scrollX=TRUE, pageLength=10))
    })

    output$syn_prtf <- DT::renderDT({
      dt <- syn_prtf_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      datatable_fr(dt, digits_cols=c("RWA_Retour4C_MEUR","RWA_Corrige_MEUR","Delta_RWA_MEUR"))
    })

    output$syn_gs <- DT::renderDT({
      dt <- syn_gs_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      datatable_fr(dt, digits_cols=c("RWA_Retour4C_MEUR","RWA_Corrige_MEUR","Delta_RWA_MEUR"))
    })

    output$corr_stats <- DT::renderDT({
      dt <- corr_stats_rv()
      if (is.null(dt)) return(DT::datatable(data.frame()))
      datatable_fr(dt, digits_cols=c("pct_remplissage"))
    })

    output$t_abs <- DT::renderDT({ dt <- top_abs(); if (is.null(dt)) DT::datatable(data.frame()) else DT::datatable(dt, options=list(scrollX=TRUE, pageLength=10)) })
    output$t_pos <- DT::renderDT({ dt <- top_pos(); if (is.null(dt)) DT::datatable(data.frame()) else DT::datatable(dt, options=list(scrollX=TRUE, pageLength=10)) })
    output$t_neg <- DT::renderDT({ dt <- top_neg(); if (is.null(dt)) DT::datatable(data.frame()) else DT::datatable(dt, options=list(scrollX=TRUE, pageLength=10)) })
    output$t_rwa <- DT::renderDT({ dt <- top_rwa(); if (is.null(dt)) DT::datatable(data.frame()) else DT::datatable(dt, options=list(scrollX=TRUE, pageLength=10)) })

    output$p_abs <- shiny::renderPlot({ plot_top(top_abs(), "Delta_RWA", "ΔRWA (MEUR)") })
    output$p_pos <- shiny::renderPlot({ plot_top(top_pos(), "Delta_RWA", "ΔRWA positif (MEUR)") })
    output$p_neg <- shiny::renderPlot({ plot_top(top_neg(), "Delta_RWA", "ΔRWA négatif (MEUR)") })
    output$p_rwa <- shiny::renderPlot({ plot_top(top_rwa(), "RWA_calc_corrige", "RWA corrigé (MEUR)") })

    output$dl <- shiny::downloadHandler(
      filename = function() paste0("rwa_recalc_compare_", Sys.Date(), ".xlsx"),
      content = function(file) {
        wb <- openxlsx::createWorkbook()

        openxlsx::addWorksheet(wb, "detail"); openxlsx::writeDataTable(wb, "detail", recalc_rv())
        openxlsx::addWorksheet(wb, "syn_prtf_ssprtf"); openxlsx::writeDataTable(wb, "syn_prtf_ssprtf", syn_prtf_rv())
        openxlsx::addWorksheet(wb, "syn_goldensource"); openxlsx::writeDataTable(wb, "syn_goldensource", syn_gs_rv())
        openxlsx::addWorksheet(wb, "corr_stats"); openxlsx::writeDataTable(wb, "corr_stats", corr_stats_rv())
        openxlsx::addWorksheet(wb, "top50_abs"); openxlsx::writeDataTable(wb, "top50_abs", top_abs())
        openxlsx::addWorksheet(wb, "top50_pos"); openxlsx::writeDataTable(wb, "top50_pos", top_pos())
        openxlsx::addWorksheet(wb, "top50_neg"); openxlsx::writeDataTable(wb, "top50_neg", top_neg())
        openxlsx::addWorksheet(wb, "top50_rwa_corrige"); openxlsx::writeDataTable(wb, "top50_rwa_corrige", top_rwa())

        openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
      }
    )
  })
}

# ------------------------- M5: Estimation RWA depuis Excel (Retail/NonRetail + PD/EAD/LGD + maturité)
mod5_ui <- function(id) {
  ns <- shiny::NS(id)
  shiny::fluidRow(
    shiny::column(4,
      shiny::card(
        shiny::card_header("Estimation RWA (Excel contrats)"),
        shiny::fileInput(ns("file"), "Choisir fichier Excel (contrats)", accept = c(".xlsx")),
        shiny::actionButton(ns("btn_preview"), "Preview (5 lignes)"),
        shiny::actionButton(ns("btn_calc"), "Calculer RWA estimé"),
        shiny::selectInput(ns("meth"), "Méthode estimation", c("IRBA (proxy)"="irba", "Standard (via RW lookup)"="sa")),
        shiny::numericInput(ns("haircut"), "Haircut (%) si Surete=1", 20, min=0, max=100),
        shiny::checkboxInput(ns("use_rw_lookup"), "Utiliser grille RW interne (SA)", TRUE),
        shiny::div(class="status-box", shiny::uiOutput(ns("task_status"))),
        shiny::uiOutput(ns("err_box")),
        shiny::tags$hr(),
        shiny::downloadButton(ns("dl"), "Télécharger rwa_estime.xlsx")
      )
    ),
    shiny::column(8,
      shiny::card(
        shiny::card_header("Résultats estimation"),
        shiny::tabsetPanel(
          shiny::tabPanel("Preview", DT::DTOutput(ns("preview"))),
          shiny::tabPanel("Résultats", DT::DTOutput(ns("res"))),
          shiny::tabPanel("Graphique", shiny::plotOutput(ns("plot"), height=320))
        )
      )
    )
  )
}

mod5_server <- function(id) {
  shiny::moduleServer(id, function(input, output, session) {
    err_rv <- shiny::reactiveVal(NULL)
    task_rv <- shiny::reactiveVal(new_task_state())
    output$err_box <- render_error_box(err_rv)
    output$task_status <- task_status_ui(task_rv)

    dt_raw <- shiny::reactiveVal(NULL)
    dt_res <- shiny::reactiveVal(NULL)

    # attendu minimal
    required_cols <- c("PRTF","SSPRTF","Segment","PD","LGD","EAD","DT_START","DT_END")
    optional_cols <- c("Surete","Default","IRB_scaling","RW")

    shiny::observeEvent(input$btn_preview, {
      req(input$file)
      run_task(task_rv, err_rv,
        label = "M5 / Preview Excel",
        prereq = paste0("Excel doit contenir au moins: ", paste(required_cols, collapse=", "), " (dates au format Excel ou texte)."),
        expr = {
          d <- readxl::read_excel(input$file$datapath)
          d <- data.table::as.data.table(d)
          data.table::setnames(d, trimws(names(d)))
          dt_raw(d)
          TRUE
        },
        ok_msg = "Preview chargé."
      )
    })

    output$preview <- DT::renderDT({
      d <- dt_raw()
      if (is.null(d)) return(DT::datatable(data.frame()))
      DT::datatable(head(d, 5), options=list(scrollX=TRUE, pageLength=5))
    })

    shiny::observeEvent(input$btn_calc, {
      req(dt_raw())
      run_task(task_rv, err_rv,
        label = "M5 / Calcul RWA estimé",
        prereq = paste0("Colonnes requises: ", paste(required_cols, collapse=", "), ". PD/LGD en % ou ratio. DT_START/DT_END convertibles en Date."),
        expr = {
          d <- data.table::copy(dt_raw())
          # normaliser colonnes requises
          miss <- setdiff(required_cols, names(d))
          if (length(miss) > 0) stop(paste0("Colonnes manquantes: ", paste(miss, collapse=", ")))

          for (cn in optional_cols) if (!cn %in% names(d)) d[, (cn) := NA]

          # dates -> Date
          # readxl peut renvoyer Date ou numeric excel
          conv_date <- function(x) {
            if (inherits(x, "Date")) return(x)
            if (is.numeric(x)) return(as.Date(x, origin="1899-12-30"))
            suppressWarnings(as.Date(as.character(x)))
          }
          d[, DT_START := conv_date(DT_START)]
          d[, DT_END   := conv_date(DT_END)]
          if (any(is.na(d$DT_START)) || any(is.na(d$DT_END))) {
            # on ne bloque pas tout, mais warning dans calc_msg
          }

          # maturité M en années
          d[, M := as.numeric(difftime(DT_END, DT_START, units="days"))/365.25]
          d[is.na(M) | M <= 0, M := NA_real_]

          # PD/LGD en ratio
          d[, PD_num := to_num_safe(PD)]
          d[, LGD_num := to_num_safe(LGD)]
          d[, PD_ratio := ifelse(!is.na(PD_num) & PD_num > 1, PD_num/100, PD_num)]
          d[, LGD_ratio := ifelse(!is.na(LGD_num) & LGD_num > 1, LGD_num/100, LGD_num)]
          d[, EAD_num := to_num_safe(EAD)]
          d[, Surete := suppressWarnings(as.integer(Surete))]
          d[is.na(Surete), Surete := 0L]
          hc <- input$haircut/100
          d[, EAD_adj := ifelse(Surete==1L, EAD_num*(1-hc), EAD_num)]

          d[, calc_flag := "OK"]
          d[, calc_msg := ""]

          if (input$meth == "irba") {
            sc <- if ("IRB_scaling" %in% names(d)) to_num_safe(IRB_scaling) else 1.0
            sc[is.na(sc)] <- 1.0
            d[, RWA_estime := 12.5 * (PD_ratio * LGD_ratio) * EAD_adj * sc]
            d[is.na(PD_ratio) | is.na(LGD_ratio) | is.na(EAD_adj), `:=`(calc_flag="KO", calc_msg="PD/LGD/EAD non numériques ou manquants.")]
          } else {
            # Standard : RW fourni ou lookup
            d[, RW_num := to_num_safe(RW)]
            d[, RW_ratio := ifelse(!is.na(RW_num) & RW_num > 2, RW_num/100, RW_num)]
            default_flag <- suppressWarnings(as.integer(Default)); default_flag[is.na(default_flag)] <- 0L

            d[, RW_used := RW_ratio]
            if (isTRUE(input$use_rw_lookup)) {
              # si RW absent, lookup
              idx_na <- is.na(d$RW_used)
              if (any(idx_na)) d[idx_na, RW_used := mapply(rw_sa_lookup, PRTF, SSPRTF, Segment, default_flag[idx_na])]
            }
            d[, RWA_estime := EAD_adj * RW_used]
            d[is.na(RW_used) | is.na(EAD_adj), `:=`(calc_flag="KO", calc_msg="RW indisponible: fournir RW ou activer lookup + mapping.")]
          }

          # sortie
          keep <- intersect(c(
            "PRTF","SSPRTF","Segment","PD","LGD","EAD","DT_START","DT_END","M",
            "Surete","Default","EAD_adj","RW","RWA_estime","calc_flag","calc_msg"
          ), names(d))
          out <- d[, ..keep]
          dt_res(out)
          TRUE
        },
        ok_msg = "RWA estimé calculé."
      )
    })

    output$res <- DT::renderDT({
      d <- dt_res()
      if (is.null(d)) return(DT::datatable(data.frame()))
      DT::datatable(d, options=list(scrollX=TRUE, pageLength=10))
    })

    output$plot <- shiny::renderPlot({
      d <- dt_res()
      req(d)
      if (!"RWA_estime" %in% names(d)) return(NULL)
      dd <- data.table::as.data.table(d)
      dd[, RWA_MEUR := to_num_safe(RWA_estime)/1e6]
      ggplot2::ggplot(dd, ggplot2::aes(x=PRTF, y=RWA_MEUR)) +
        ggplot2::geom_boxplot() +
        ggplot2::theme_minimal() +
        ggplot2::labs(y="RWA estimé (MEUR)", x="PRTF")
    })

    output$dl <- shiny::downloadHandler(
      filename = function() paste0("rwa_estime_", Sys.Date(), ".xlsx"),
      content = function(file) {
        wb <- openxlsx::createWorkbook()
        openxlsx::addWorksheet(wb, "rwa_estime")
        openxlsx::writeDataTable(wb, "rwa_estime", dt_res())
        openxlsx::saveWorkbook(wb, file, overwrite = TRUE)
      }
    )
  })
}

# ============================================================
# [05] SHARED STATE (entre modules)
# ============================================================
shared <- new.env(parent = emptyenv())
shared$ret_prep <- shiny::reactiveVal(NULL)
shared$ret_syn  <- shiny::reactiveVal(NULL)
shared$ret_meta <- shiny::reactiveVal(NULL)

shared$ano_dt     <- shiny::reactiveVal(NULL)
shared$extract_dt <- shiny::reactiveVal(NULL)

# ============================================================
# [06] UI GLOBAL
# ============================================================
ui <- shiny::fluidPage(
  shinyjs::useShinyjs(),
  bslib::theme = bslib::bs_theme(version = 5, bootswatch = "flatly"),
  shiny::tags$style(HTML("
    .small-note{font-size:12px;color:#666;}
    .status-box{padding:10px;border-radius:8px;background:#f7f9fb;border:1px solid #e5e9ef;margin-top:10px;}
  ")),
  shiny::titlePanel("Application RShiny RWA - Stable & Modulaire"),

  shiny::tabsetPanel(
    shiny::tabPanel("0) Setup & Self-Test", mod0_ui("m0")),
    shiny::tabPanel("1) Calcul RWA",        mod1_ui("m1")),
    shiny::tabPanel("2) Retour4C",          mod2_ui("m2")),
    shiny::tabPanel("3) Anomalies",         mod3_ui("m3")),
    shiny::tabPanel("4) Recalcul RWA",      mod4_ui("m4")),
    shiny::tabPanel("5) Estimation Excel",  mod5_ui("m5"))
  )
)

# ============================================================
# [07] SERVER GLOBAL
# ============================================================
server <- function(input, output, session) {

  # check packages at startup, warn if missing
  shiny::observe({
    miss <- pkg_missing(required_pkgs)
    if (length(miss) > 0) {
      showNotification(
        paste0("⚠️ Packages manquants: ", paste(miss, collapse=", "),
               " — allez dans l’onglet 0) Setup et cliquez sur Installer."),
        type = "warning", duration = 8
      )
    }
  })

  mod0_server("m0")
  mod1_server("m1")
  mod2_server("m2", shared)
  mod3_server("m3", shared)
  mod4_server("m4", shared)
  mod5_server("m5")
}

shiny::shinyApp(ui, server)