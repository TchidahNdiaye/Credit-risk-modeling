# ============================================================
#  Application RShiny RWA - Standard & IRBA | Retour4C | DQ
#  Version renforcée :
#   - Minuteur + état d'avancement + message OK sur CHAQUE action
#   - Gestion d'erreur IHM : prérequis + trace + (si dispo) ligne de code
#   - Module 4 : corrections *_corrige toutes optionnelles
#   - Module 4 : Top50 |ΔRWA| + Top50 Δ+ + Top50 Δ- + Top50 RWA corrigé + graphes
#   - Export Excel multi-onglets (detail + synthèses + stats + tops)
# ============================================================

suppressPackageStartupMessages({
  library(shiny)
  library(bslib)
  library(shinyjs)
  library(data.table)
  library(DT)
  library(ggplot2)
  library(readxl)
  library(openxlsx)
})

# ------------------------------------------------------------
# Helpers: extraction ligne (si srcref disponible)
# ------------------------------------------------------------
extract_line_from_calls <- function() {
  calls <- sys.calls()
  for (i in rev(seq_along(calls))) {
    sr <- attr(calls[[i]], "srcref")
    if (!is.null(sr) && length(sr) >= 1) {
      line <- tryCatch(as.integer(sr[[1]]), error = function(e) NA_integer_)
      return(list(line = line, srcref = sr))
    }
  }
  NULL
}

# ------------------------------------------------------------
# Utils: wrapper sécurisé + message erreur IHM complet
# ------------------------------------------------------------
safe_run <- function(action_label, prereq_text, expr) {
  tryCatch(
    {
      res <- eval.parent(substitute(expr))
      list(ok = TRUE, result = res)
    },
    error = function(e) {
      line_info <- extract_line_from_calls()
      line_txt <- if (!is.null(line_info) && !is.na(line_info$line)) {
        paste0("Ligne (approx.): ", line_info$line)
      } else {
        "Ligne: non disponible (srcref absent)"
      }

      dbg <- paste0(
        "=== ACTION: ", action_label, " ===\n",
        "ERROR: ", conditionMessage(e), "\n",
        line_txt, "\n",
        "CALL: ", paste(deparse(conditionCall(e)), collapse = " "), "\n\n",
        "TRACE:\n", paste(capture.output(traceback(2)), collapse = "\n")
      )

      list(
        ok = FALSE,
        user_msg = paste0(
          "Erreur pendant: ", action_label, "\n\n",
          "Pré-requis / piste de correction:\n- ", prereq_text, "\n\n",
          line_txt
        ),
        debug = dbg
      )
    }
  )
}

render_error_box <- function(err_rv) {
  renderUI({
    err <- err_rv()
    if (is.null(err)) return(NULL)
    div(
      style = "border:1px solid #d9534f; background:#fff5f5; padding:12px; border-radius:8px; margin-top:10px;",
      tags$b("❌ Erreur"),
      tags$pre(style="white-space:pre-wrap; font-size:12px;", err$user_msg),
      tags$details(
        tags$summary("Détails techniques (trace)"),
        tags$pre(style="white-space:pre-wrap; font-size:11px;", err$debug)
      )
    )
  })
}

# ------------------------------------------------------------
# Utils: statut tâche + minuteur
# ------------------------------------------------------------
new_task_state <- function() {
  list(
    running = FALSE,
    label = "",
    start_time = NULL,
    last_msg = "",
    ok = NULL
  )
}

elapsed_secs <- function(t0) {
  if (is.null(t0)) return(0L)
  as.integer(difftime(Sys.time(), t0, units = "secs"))
}

task_ui <- function(state_rv) {
  renderUI({
    st <- state_rv()
    if (is.null(st) || (!isTRUE(st$running) && is.null(st$ok))) {
      return(div(class = "small-note", "Aucune tâche en cours."))
    }
    secs <- elapsed_secs(st$start_time)
    if (isTRUE(st$running)) {
      div(
        tags$b("⏳ ", st$label, " "),
        tags$span(paste0("(", secs, "s)")),
        tags$div(class="small-note", st$last_msg)
      )
    } else if (isTRUE(st$ok)) {
      div(
        tags$b("✅ ", st$label, " - Terminé"),
        tags$span(class="small-note", paste0(" (", secs, "s)")),
        tags$div(class="small-note", st$last_msg)
      )
    } else {
      div(
        tags$b("❌ ", st$label, " - Échec"),
        tags$span(class="small-note", paste0(" (", secs, "s)")),
        tags$div(class="small-note", st$last_msg)
      )
    }
  })
}

# Runner générique pour chaque bouton : status + progress + notif OK/KO
run_task <- function(state_rv, err_rv, action_label, prereq_text, expr, success_msg = "Tâche exécutée avec succès.") {
  err_rv(NULL)
  state_rv(modifyList(new_task_state(), list(
    running = TRUE,
    label = action_label,
    start_time = Sys.time(),
    last_msg = "Démarrage..."
  )))

  # Progress bar Shiny
  res <- withProgress(message = action_label, value = 0, {
    incProgress(0.05, detail = "Initialisation...")
    out <- safe_run(action_label, prereq_text, {
      incProgress(0.20, detail = "Lecture / préparation...")
      val <- eval.parent(substitute(expr))
      incProgress(0.75, detail = "Finalisation...")
      val
    })
    incProgress(1.0, detail = "Terminé")
    out
  })

  if (isTRUE(res$ok)) {
    state_rv(modifyList(state_rv(), list(
      running = FALSE,
      ok = TRUE,
      last_msg = success_msg
    )))
    showNotification(paste0("✅ ", action_label, " : OK"), type = "message", duration = 4)
    return(invisible(res$result))
  } else {
    state_rv(modifyList(state_rv(), list(
      running = FALSE,
      ok = FALSE,
      last_msg = "Erreur - voir bloc rouge ci-dessous."
    )))
    err_rv(res)
    showNotification(paste0("❌ ", action_label, " : Erreur"), type = "error", duration = 6)
    return(invisible(NULL))
  }
}

# ------------------------------------------------------------
# Utils: lecture gros fichiers (CSV/TXT) auto sep/dec
# ------------------------------------------------------------
count_fixed <- function(s, pattern) {
  m <- gregexpr(pattern, s, fixed = TRUE)[[1]]
  if (length(m) == 1 && m[1] == -1) return(0L)
  length(m)
}
detect_sep <- function(path) {
  ln <- readLines(path, n = 5, warn = FALSE, encoding = "UTF-8")
  ln <- ln[nzchar(ln)]
  if (length(ln) == 0) return(",")
  l1 <- ln[1]
  candidates <- c(";", ",", "\t", "|")
  counts <- sapply(candidates, function(s) count_fixed(l1, s))
  candidates[which.max(counts)]
}
detect_dec <- function(sep) if (identical(sep, ";")) "," else "."

safe_fread_preview <- function(path) {
  sep <- detect_sep(path); dec <- detect_dec(sep)
  dt <- fread(path, sep = sep, dec = dec, nrows = 5, showProgress = FALSE, encoding = "UTF-8", fill = TRUE)
  list(dt = dt, sep = sep, dec = dec)
}
safe_fread_full <- function(path) {
  sep <- detect_sep(path); dec <- detect_dec(sep)
  dt <- fread(path, sep = sep, dec = dec, showProgress = TRUE, encoding = "UTF-8", fill = TRUE)
  list(dt = dt, sep = sep, dec = dec)
}

# ------------------------------------------------------------
# Utils: préparation Retour4C
# ------------------------------------------------------------
to_num_safe <- function(x) {
  if (is.numeric(x)) return(x)
  x <- as.character(x)
  x <- gsub("\u00A0", " ", x)
  x <- gsub(" ", "", x)
  x <- sub(",", ".", x, fixed = TRUE)
  suppressWarnings(as.numeric(x))
}
normalize_colnames <- function(dt) {
  setnames(dt, trimws(names(dt)))
  dt
}
prepare_retour4c <- function(dt) {
  dt <- as.data.table(dt)
  dt <- normalize_colnames(dt)

  if (!"OBS_ID" %in% names(dt)) dt[, OBS_ID := .I]

  for (cn in c("GoldenSource", "PRTF", "SSPRTF", "Segment", "PRODUCT_ID")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA_character_]
    dt[is.na(get(cn)) | trimws(get(cn)) == "", (cn) := "UNKNOWN"]
  }

  if (!"ASOF_DT" %in% names(dt)) dt[, ASOF_DT := NA_character_]
  dt[, ASOF := suppressWarnings(as.IDate(ASOF_DT, format = "%Y-%m-%d"))]
  idx_na <- is.na(dt$ASOF) & !is.na(dt$ASOF_DT)
  if (any(idx_na)) dt[idx_na, ASOF := suppressWarnings(as.IDate(ASOF_DT, format = "%d/%m/%Y"))]

  for (cn in c("Encours","EAD","RWA","EAD_B","EAD_HB","CCF","RW","PD","LGD","M")) {
    if (!cn %in% names(dt)) dt[, (cn) := NA]
  }
  dt[, Encours := to_num_safe(Encours)]
  dt[, EAD     := to_num_safe(EAD)]
  dt[, RWA     := to_num_safe(RWA)]
  dt[, EAD_B   := to_num_safe(EAD_B)]
  dt[, EAD_HB  := to_num_safe(EAD_HB)]
  dt[, CCF     := to_num_safe(CCF)]
  dt[, RW      := to_num_safe(RW)]
  dt[, PD      := to_num_safe(PD)]
  dt[, LGD     := to_num_safe(LGD)]
  dt[, M       := to_num_safe(M)]

  id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
  for (cn in intersect(id_cols, names(dt))) dt[, (cn) := trimws(as.character(get(cn)))]

  dt
}

# ------------------------------------------------------------
# Utils: canonisation ID (Excel scientific etc.)
# ------------------------------------------------------------
canon_id <- function(x) {
  x <- as.character(x)
  x <- trimws(x)
  x <- toupper(x)
  x <- gsub("\\s+", "", x)

  sci <- grepl("^[0-9]+\\.?[0-9]*E[+-]?[0-9]+$", x, ignore.case = TRUE)
  if (any(sci, na.rm = TRUE)) {
    suppressWarnings({
      num <- as.numeric(x[sci])
      x[sci] <- format(num, scientific = FALSE, trim = TRUE, digits = 22)
      x[sci] <- gsub("\\.0$", "", x[sci])
      x[sci] <- gsub("\\s+", "", x[sci])
    })
  }
  x
}

# ------------------------------------------------------------
# DT format FR (milliers + 2 décimales)
# ------------------------------------------------------------
datatable_fr <- function(df, digits_cols = NULL) {
  dt <- datatable(df, options = list(pageLength = 10, scrollX = TRUE))
  if (!is.null(digits_cols) && length(digits_cols) > 0) {
    dt <- formatRound(dt, columns = digits_cols, digits = 2, mark = " ", decMark = ",")
  }
  dt
}

# ------------------------------------------------------------
# RW Standard (EXEMPLE - à adapter)
# ------------------------------------------------------------
rw_sa_lookup <- function(PRTF, SSPRTF, Segment, DefaultFlag) {
  PRTF <- toupper(PRTF); SSPRTF <- toupper(SSPRTF); Segment <- toupper(Segment)
  if (!is.na(DefaultFlag) && DefaultFlag == 1L) return(1.00)
  if (PRTF == "RETAIL") {
    if (SSPRTF == "IMMOBILIER") return(0.35)
    if (SSPRTF == "REVOLVING")  return(0.75)
    return(0.75)
  }
  if (grepl("SME", Segment)) return(0.85)
  return(1.00)
}

# ------------------------------------------------------------
# Appliquer toutes corrections *_corrige (optionnelles)
# ------------------------------------------------------------
apply_corrige_generic <- function(x) {
  x <- as.data.table(x)
  corr_cols <- grep("_corrige$", names(x), value = TRUE)
  for (cc in corr_cols) {
    base <- sub("_corrige$", "", cc)
    if (base %in% names(x)) {
      if (is.numeric(x[[base]]) || base %in% c("EAD","RWA","Encours","EAD_B","EAD_HB","CCF","RW","PD","LGD","M")) {
        x[, (base) := fifelse(!is.na(to_num_safe(get(cc))), to_num_safe(get(cc)), get(base))]
      } else {
        x[, (base) := fifelse(!is.na(get(cc)) & trimws(as.character(get(cc))) != "", as.character(get(cc)), as.character(get(base)))]
      }
    }
  }
  x
}

# ------------------------------------------------------------
# Synthèses Module 2
# ------------------------------------------------------------
compute_syntheses_ret <- function(dt) {
  dt <- copy(dt)
  for (cn in c("ASOF","GoldenSource","PRTF","Encours","EAD","RWA")) if (!cn %in% names(dt)) dt[, (cn) := NA]
  dt[, Encours := to_num_safe(Encours)]
  dt[, EAD := to_num_safe(EAD)]
  dt[, RWA := to_num_safe(RWA)]

  gs <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF, GoldenSource)]
  gs_total <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF)][, GoldenSource := "TOTAL"][]
  gs_out <- rbind(gs, gs_total, fill=TRUE)

  pr <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF, PRTF)]
  pr_total <- dt[, .(
    Nbre_observations = .N,
    Encours_MEUR = sum(Encours, na.rm=TRUE)/1e6,
    EAD_MEUR = sum(EAD, na.rm=TRUE)/1e6,
    RWA_MEUR = sum(RWA, na.rm=TRUE)/1e6
  ), by = .(ASOF)][, PRTF := "TOTAL"][]
  pr_out <- rbind(pr, pr_total, fill=TRUE)

  list(gs = gs_out, pr = pr_out)
}

# ------------------------------------------------------------
# Synthèses Module 4 (impacts)
# ------------------------------------------------------------
compute_recalc_summaries <- function(x) {
  x <- copy(x)
  for (cn in c("PRTF","SSPRTF","GoldenSource","RWA_retour4c","RWA_calc_corrige","Delta_RWA")) if (!cn %in% names(x)) x[, (cn) := NA]

  syn_prtf <- x[, .(
    Nbre_observations = .N,
    RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
    RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
    Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
  ), by = .(PRTF, SSPRTF)]
  syn_prtf_total <- x[, .(
    Nbre_observations = .N,
    RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
    RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
    Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
  )][, `:=`(PRTF="TOTAL", SSPRTF="TOTAL")][]
  syn_prtf <- rbind(syn_prtf, syn_prtf_total, fill=TRUE)

  syn_gs <- x[, .(
    Nbre_observations = .N,
    RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
    RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
    Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
  ), by = .(GoldenSource)]
  syn_gs_total <- x[, .(
    Nbre_observations = .N,
    RWA_Retour4C_MEUR = sum(RWA_retour4c, na.rm=TRUE)/1e6,
    RWA_Corrige_MEUR  = sum(RWA_calc_corrige, na.rm=TRUE)/1e6,
    Delta_RWA_MEUR    = sum(Delta_RWA, na.rm=TRUE)/1e6
  )][, GoldenSource := "TOTAL"][]
  syn_gs <- rbind(syn_gs, syn_gs_total, fill=TRUE)

  list(syn_prtf = syn_prtf, syn_gs = syn_gs)
}

compute_corr_stats <- function(a) {
  a <- copy(a)
  corr_cols <- grep("_corrige$", names(a), value = TRUE)
  if (length(corr_cols) == 0) {
    return(data.table(variable_corrige=character(), pct_remplissage=numeric(), nb_lignes_remplies=integer(), exemple=character()))
  }
  stats <- rbindlist(lapply(corr_cols, function(cc) {
    v <- a[[cc]]
    filled <- !is.na(v) & trimws(as.character(v)) != ""
    data.table(
      variable_corrige = cc,
      pct_remplissage = round(100 * mean(filled), 2),
      nb_lignes_remplies = sum(filled),
      exemple = { idx <- which(filled)[1]; if (length(idx)==0) "" else as.character(v[idx]) }
    )
  }), fill = TRUE)
  stats[order(-nb_lignes_remplies, variable_corrige)]
}

# ------------------------------------------------------------
# TOPS Module 4
# ------------------------------------------------------------
compute_tops <- function(x_out) {
  tt <- copy(x_out)
  tt[, abs_delta := abs(Delta_RWA)]
  tt_pos <- tt[!is.na(Delta_RWA) & Delta_RWA > 0][order(-Delta_RWA)]
  tt_neg <- tt[!is.na(Delta_RWA) & Delta_RWA < 0][order(Delta_RWA)]  # plus négatif d'abord
  tt_abs <- tt[!is.na(abs_delta)][order(-abs_delta)]

  tt_rwa <- tt[!is.na(RWA_calc_corrige)][order(-RWA_calc_corrige)]

  keep <- intersect(c(
    "ID_CONTRAT","ID_CONTRAT_CANON","GoldenSource","PRTF","SSPRTF","Segment","PRODUCT_ID","ASOF_DT","MATCHED_ON",
    "EAD_eff","EAD_adj","RW_used",
    "RWA_retour4c","RWA_calc_corrige","Delta_RWA","corrections_appliquees","calc_flag","calc_msg"
  ), names(tt))

  list(
    top50_abs = head(tt_abs[, ..keep], 50),
    top50_pos = head(tt_pos[, ..keep], 50),
    top50_neg = head(tt_neg[, ..keep], 50),
    top50_rwa = head(tt_rwa[, ..keep], 50)
  )
}

# ============================================================
# UI
# ============================================================
ui <- fluidPage(
  useShinyjs(),
  theme = bs_theme(version = 5, bootswatch = "flatly"),
  tags$style(HTML("
    .small-note{font-size:12px;color:#666;}
    .status-box{padding:10px;border-radius:8px;background:#f7f9fb;border:1px solid #e5e9ef;margin-top:10px;}
  ")),

  titlePanel("Application RShiny RWA - Standard & IRBA | Retour4C | Data Quality"),

  tabsetPanel(
    tabPanel("1) Calcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Paramètres"),
            selectInput("meth", "Méthode", c("Standard", "IRBA")),
            hr(),
            h5("Standard"),
            numericInput("ead_init", "EAD initial", value = 1000000),
            numericInput("ead_corr", "EAD corrigé", value = 1000000),
            numericInput("rw_init", "RW initial (%)", value = 50),
            numericInput("rw_corr", "RW corrigé (%)", value = 45),
            checkboxInput("surete", "Sûreté (Oui/Non)", value = FALSE),
            numericInput("haircut", "Haircut (%)", value = 20, min = 0, max = 100),
            hr(),
            h5("Bilan / Hors-bilan (Standard)"),
            numericInput("ead_b_init", "EAD_B initial", value = 700000),
            numericInput("ead_b_corr", "EAD_B corrigé", value = 700000),
            numericInput("ead_hb_init", "EAD_HB initial", value = 300000),
            numericInput("ead_hb_corr", "EAD_HB corrigé", value = 300000),
            numericInput("ccf_init", "CCF initial (%)", value = 50),
            numericInput("ccf_corr", "CCF corrigé (%)", value = 40),
            hr(),
            h5("IRBA (proxy)"),
            numericInput("pd_init", "PD initial (%)", value = 1),
            numericInput("pd_corr", "PD corrigé (%)", value = 1),
            numericInput("lgd_init", "LGD initial (%)", value = 45),
            numericInput("lgd_corr", "LGD corrigé (%)", value = 45),
            numericInput("m_init", "M initial (années)", value = 2.5),
            numericInput("m_corr", "M corrigé (années)", value = 2.5),
            numericInput("scaling", "Scaling", value = 1.0)
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            verbatimTextOutput("calc_out"),
            plotOutput("calc_plot", height = 300)
          )
        )
      )
    ),

    tabPanel("2) Retour4C",
      fluidRow(
        column(4,
          card(
            card_header("Chargement Retour4C (CSV ou TXT)"),
            fileInput("ret_file", "Choisir Retour4C (.csv/.txt)", accept = c(".csv",".txt")),
            div(class="small-note","Séparateur et décimale détectés automatiquement."),
            actionButton("btn_preview", "Afficher preview (5 lignes)"),
            actionButton("btn_load", "Charger complet + préparer"),
            actionButton("btn_syn", "Calculer / Recalculer les synthèses"),
            div(class="status-box", uiOutput("task_mod2_status")),
            uiOutput("err_mod2")
          )
        ),
        column(8,
          card(
            card_header("Résultats"),
            tabsetPanel(
              tabPanel("Preview", DTOutput("ret_preview")),
              tabPanel("Arrêté/Infos", uiOutput("ret_info")),
              tabPanel("Synthèse GoldenSource", uiOutput("syn_note"), DTOutput("syn_gs")),
              tabPanel("Synthèse Portefeuille Bâlois", uiOutput("syn_note2"), DTOutput("syn_prtf"))
            )
          )
        )
      )
    ),

    tabPanel("3) Anomalies",
      fluidRow(
        column(4,
          card(
            card_header("Charger anomalies_dq.xlsx"),
            fileInput("ano_file", "Choisir anomalies_dq.xlsx", accept = c(".xlsx")),
            actionButton("btn_ano_preview", "Afficher preview anomalies (5 lignes)"),
            actionButton("btn_extract", "Extraire dans Retour4C"),
            div(class="status-box", uiOutput("task_mod3_status")),
            uiOutput("err_mod3"),
            div(class="small-note","Extraction = Retour4C préparé + anomalies chargées. Retour4C doit contenir au moins une colonne ID.")
          )
        ),
        column(8,
          card(
            card_header("Résultats anomalies"),
            tabsetPanel(
              tabPanel("Preview anomalies", DTOutput("ano_preview")),
              tabPanel("Résultat extraction", DTOutput("ano_extract")),
              tabPanel("Diagnostic matching", verbatimTextOutput("ano_diag")),
              tabPanel("Export", downloadButton("dl_extract", "Télécharger ead_rwa_ano_dq.xlsx"))
            )
          )
        )
      )
    ),

    tabPanel("4) Recalcul RWA",
      fluidRow(
        column(4,
          card(
            card_header("Recalcul DQ & comparaison (tout optionnel)"),
            selectInput("recalc_meth", "Méthode", c("standard","irba")),
            numericInput("recalc_haircut", "Haircut (%) (si Surete=1)", value = 20, min = 0, max = 100),
            checkboxInput("use_rw_lookup", "Utiliser la grille RW interne si classification corrigée", value = TRUE),
            actionButton("btn_recalc", "Recalculer & comparer"),
            div(class="status-box", uiOutput("task_mod4_status")),
            uiOutput("err_mod4"),
            downloadButton("dl_recalc", "Télécharger rwa_recalc_compare.xlsx")
          )
        ),
        column(8,
          card(
            card_header("Résultats Module 4"),
            tabsetPanel(
              tabPanel("Détail (ligne par ligne)", DTOutput("recalc_tbl")),
              tabPanel("Synthèse impacts", uiOutput("recalc_syn_note"),
                       h5("Par Portefeuille Bâlois (PRTF/SSPRTF)"), DTOutput("recalc_syn_prtf"),
                       tags$hr(),
                       h5("Par GoldenSource"), DTOutput("recalc_syn_gs")),
              tabPanel("Qualité corrections (_corrige)", uiOutput("corr_note"), DTOutput("corr_stats_tbl")),
              tabPanel("Top 50",
                uiOutput("top_note"),
                tabsetPanel(
                  tabPanel("Top50 |ΔRWA|", DTOutput("top50_abs_tbl"), plotOutput("top50_abs_plot", height = 360)),
                  tabPanel("Top50 ΔRWA positif", DTOutput("top50_pos_tbl"), plotOutput("top50_pos_plot", height = 360)),
                  tabPanel("Top50 ΔRWA négatif", DTOutput("top50_neg_tbl"), plotOutput("top50_neg_plot", height = 360)),
                  tabPanel("Top50 RWA corrigé", DTOutput("top50_rwa_tbl"), plotOutput("top50_rwa_plot", height = 360))
                )
              )
            )
          )
        )
      )
    )
  )
)

# ============================================================
# SERVER
# ============================================================
server <- function(input, output, session) {

  # -------- erreurs
  err_mod2_rv <- reactiveVal(NULL)
  err_mod3_rv <- reactiveVal(NULL)
  err_mod4_rv <- reactiveVal(NULL)
  output$err_mod2 <- render_error_box(err_mod2_rv)
  output$err_mod3 <- render_error_box(err_mod3_rv)
  output$err_mod4 <- render_error_box(err_mod4_rv)

  # -------- états tâches (minuteurs)
  task_mod2 <- reactiveVal(new_task_state())
  task_mod3 <- reactiveVal(new_task_state())
  task_mod4 <- reactiveVal(new_task_state())
  output$task_mod2_status <- task_ui(task_mod2)
  output$task_mod3_status <- task_ui(task_mod3)
  output$task_mod4_status <- task_ui(task_mod4)

  # Force refresh minuteurs chaque seconde
  observe({
    invalidateLater(1000, session)
    # juste pour déclencher re-render
    task_mod2(task_mod2()); task_mod3(task_mod3()); task_mod4(task_mod4())
  })

  # -------- datas
  ret_prep <- reactiveVal(NULL)
  ret_preview_rv <- reactiveVal(NULL)
  ret_meta <- reactiveVal(list(sep=NULL, dec=NULL, loaded=FALSE))
  syn_rv <- reactiveVal(NULL)
  syn_ts <- reactiveVal(NULL)

  ano_dt <- reactiveVal(NULL)
  ano_preview_rv <- reactiveVal(NULL)
  extract_dt <- reactiveVal(NULL)
  diag_txt <- reactiveVal("")

  recalc_dt <- reactiveVal(NULL)
  recalc_syn_prtf_rv <- reactiveVal(NULL)
  recalc_syn_gs_rv <- reactiveVal(NULL)
  corr_stats_rv <- reactiveVal(NULL)
  recalc_ts <- reactiveVal(NULL)

  tops_abs <- reactiveVal(NULL)
  tops_pos <- reactiveVal(NULL)
  tops_neg <- reactiveVal(NULL)
  tops_rwa <- reactiveVal(NULL)

  # ============================================================
  # MODULE 1 - Calcul IHM
  # ============================================================
  output$calc_out <- renderPrint({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init; ead_c <- input$ead_corr
      rw_i <- input$rw_init/100; rw_c <- input$rw_corr/100
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1
      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c

      ccf_i <- input$ccf_init/100; ccf_c <- input$ccf_corr/100
      rwa_b_i <- input$ead_b_init * rw_i
      rwa_b_c <- input$ead_b_corr * rw_c
      rwa_hb_i <- (input$ead_hb_init * ccf_i) * rw_i
      rwa_hb_c <- (input$ead_hb_corr * ccf_c) * rw_c

      list(
        Standard = data.frame(RWA_initial = rwa_i, RWA_corrige = rwa_c, Delta = rwa_c - rwa_i),
        Bilan_HorsBilan = data.frame(
          RWA_B_initial = rwa_b_i, RWA_B_corrige = rwa_b_c,
          RWA_HB_initial = rwa_hb_i, RWA_HB_corrige = rwa_hb_c,
          RWA_Total_initial = rwa_b_i + rwa_hb_i,
          RWA_Total_corrige = rwa_b_c + rwa_hb_c
        )
      )
    } else {
      ead_i <- input$ead_init; ead_c <- input$ead_corr
      pd_i <- input$pd_init/100; pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100; lgd_c <- input$lgd_corr/100
      sc <- input$scaling
      K_i <- pd_i * lgd_i
      K_c <- pd_c * lgd_c
      rwa_i <- 12.5 * K_i * ead_i * sc
      rwa_c <- 12.5 * K_c * ead_c * sc
      data.frame(RWA_initial = rwa_i, RWA_corrige = rwa_c, Delta = rwa_c - rwa_i)
    }
  })

  output$calc_plot <- renderPlot({
    if (input$meth == "Standard") {
      ead_i <- input$ead_init; ead_c <- input$ead_corr
      rw_i <- input$rw_init/100; rw_c <- input$rw_corr/100
      hc <- input$haircut/100
      adj <- if (isTRUE(input$surete)) (1 - hc) else 1
      rwa_i <- (ead_i * adj) * rw_i
      rwa_c <- (ead_c * adj) * rw_c
    } else {
      ead_i <- input$ead_init; ead_c <- input$ead_corr
      pd_i <- input$pd_init/100; pd_c <- input$pd_corr/100
      lgd_i <- input$lgd_init/100; lgd_c <- input$lgd_corr/100
      sc <- input$scaling
      rwa_i <- 12.5 * (pd_i * lgd_i) * ead_i * sc
      rwa_c <- 12.5 * (pd_c * lgd_c) * ead_c * sc
    }
    df <- data.frame(Type = c("Initial","Corrigé"), RWA = c(rwa_i, rwa_c))
    ggplot(df, aes(x=Type, y=RWA)) + geom_col() + theme_minimal()
  })

  # ============================================================
  # MODULE 2 - Retour4C
  # ============================================================
  observeEvent(input$btn_preview, {
    req(input$ret_file)
    run_task(
      task_mod2, err_mod2_rv,
      action_label = "Module 2 / Preview Retour4C",
      prereq_text = "Sélectionner un fichier Retour4C (.csv/.txt) non vide.",
      expr = {
        task_mod2(modifyList(task_mod2(), list(last_msg = "Détection séparateur / décimale...")))
        pv <- safe_fread_preview(input$ret_file$datapath)
        ret_preview_rv(pv$dt)
        ret_meta(modifyList(ret_meta(), list(sep=pv$sep, dec=pv$dec)))
        pv$dt
      },
      success_msg = "Preview affiché (5 lignes)."
    )
  })

  output$ret_preview <- renderDT({
    dt <- ret_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_load, {
    req(input$ret_file)
    run_task(
      task_mod2, err_mod2_rv,
      action_label = "Module 2 / Charger complet + préparer",
      prereq_text = "Fichier Retour4C lisible (csv/txt). Recommandé pour synthèses: ASOF_DT, GoldenSource, PRTF, Encours, EAD, RWA.",
      expr = {
        task_mod2(modifyList(task_mod2(), list(last_msg = "Lecture complète du fichier...")))
        full <- safe_fread_full(input$ret_file$datapath)
        task_mod2(modifyList(task_mod2(), list(last_msg = "Préparation des colonnes (ASOF, montants, IDs)...")))
        dt_p <- prepare_retour4c(full$dt)
        ret_prep(dt_p)
        ret_meta(modifyList(ret_meta(), list(sep=full$sep, dec=full$dec, loaded=TRUE)))

        task_mod2(modifyList(task_mod2(), list(last_msg = "Calcul automatique des synthèses...")))
        syn <- compute_syntheses_ret(dt_p)
        syn_rv(syn)
        syn_ts(Sys.time())
        dt_p
      },
      success_msg = "Chargement + préparation terminés. Synthèses calculées."
    )
  })

  observeEvent(input$btn_syn, {
    req(ret_prep())
    run_task(
      task_mod2, err_mod2_rv,
      action_label = "Module 2 / Recalcul synthèses",
      prereq_text = "Charger Retour4C via 'Charger complet + préparer' avant de recalculer.",
      expr = {
        task_mod2(modifyList(task_mod2(), list(last_msg = "Agrégations GoldenSource / PRTF...")))
        syn <- compute_syntheses_ret(ret_prep())
        syn_rv(syn)
        syn_ts(Sys.time())
        syn
      },
      success_msg = "Synthèses recalculées."
    )
  })

  output$syn_note <- renderUI({
    if (is.null(syn_rv())) return(div(class="small-note","Synthèses non calculées."))
    div(class="small-note", paste0("Dernier calcul synthèses: ", format(syn_ts(), "%Y-%m-%d %H:%M:%S")))
  })
  output$syn_note2 <- output$syn_note

  output$syn_gs <- renderDT({
    syn <- syn_rv()
    if (is.null(syn)) return(datatable(data.frame()))
    datatable_fr(syn$gs, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
  })
  output$syn_prtf <- renderDT({
    syn <- syn_rv()
    if (is.null(syn)) return(datatable(data.frame()))
    datatable_fr(syn$pr, digits_cols = c("Encours_MEUR","EAD_MEUR","RWA_MEUR"))
  })

  output$ret_info <- renderUI({
    dt <- ret_prep()
    if (is.null(dt)) return(div(class="small-note", "Charger Retour4C pour afficher l'arrêté et la description globale."))

    asof_max <- dt[, suppressWarnings(max(ASOF, na.rm=TRUE))]
    asof_txt <- if (!is.na(asof_max)) as.character(asof_max) else "NA"
    n <- nrow(dt); p <- ncol(dt)
    mem_mb <- round(as.numeric(object.size(dt)) / 1024^2, 1)

    smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        idx <- which(!is.na(x))[1]
        if (is.na(idx)) "" else as.character(x[idx])
      })
    )

    tagList(
      h4("Arrêté"),
      tags$p(tags$b("Arrêté (max ASOF) : "), asof_txt),
      hr(),
      h4("Description globale Retour4C"),
      tags$ul(
        tags$li(paste0("Nombre de lignes: ", format(n, big.mark=" ", decimal.mark=","))),
        tags$li(paste0("Nombre de colonnes: ", p)),
        tags$li(paste0("Taille mémoire approx: ", mem_mb, " MB"))
      ),
      h5("Dictionnaire (échantillon)"),
      DTOutput("ret_dict")
    )
  })

  output$ret_dict <- renderDT({
    dt <- ret_prep(); req(dt)
    n <- nrow(dt); smp_n <- min(50000, n)
    smp <- dt[seq_len(smp_n)]
    dict <- data.table(
      variable = names(smp),
      classe = sapply(smp, function(x) paste(class(x), collapse=",")),
      pct_na = round(100 * sapply(smp, function(x) mean(is.na(x))), 2),
      exemple = sapply(smp, function(x) {
        idx <- which(!is.na(x))[1]
        if (is.na(idx)) "" else as.character(x[idx])
      })
    )
    datatable(dict, options = list(scrollX=TRUE, pageLength=10))
  })

  # ============================================================
  # MODULE 3 - Anomalies
  # ============================================================
  observeEvent(input$btn_ano_preview, {
    req(input$ano_file)
    run_task(
      task_mod3, err_mod3_rv,
      action_label = "Module 3 / Preview anomalies",
      prereq_text = "Le fichier anomalies_dq.xlsx doit contenir la colonne ID_CONTRAT (format texte recommandé).",
      expr = {
        task_mod3(modifyList(task_mod3(), list(last_msg = "Lecture Excel (en texte)...")))
        a <- read_excel(input$ano_file$datapath, col_types = "text")
        a <- as.data.table(a)
        setnames(a, trimws(names(a)))

        cn_norm <- toupper(gsub("\\s+", "", names(a)))
        idx <- which(cn_norm == "ID_CONTRAT")
        if (length(idx) == 0) stop("Colonne ID_CONTRAT introuvable dans anomalies_dq.xlsx.")
        setnames(a, names(a)[idx[1]], "ID_CONTRAT")

        task_mod3(modifyList(task_mod3(), list(last_msg = "Canonisation des ID (anti scientific Excel)...")))
        a[, ID_CONTRAT_RAW := ID_CONTRAT]
        a[, ID_CONTRAT_CANON := canon_id(ID_CONTRAT)]

        ano_dt(a)
        ano_preview_rv(head(a, 5))
        a
      },
      success_msg = "Preview anomalies affiché (5 lignes)."
    )
  })

  output$ano_preview <- renderDT({
    dt <- ano_preview_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 5))
  })

  observeEvent(input$btn_extract, {
    req(ano_dt()); req(ret_prep())

    run_task(
      task_mod3, err_mod3_rv,
      action_label = "Module 3 / Extraction anomalies dans Retour4C",
      prereq_text = paste(
        "1) Charger Retour4C (Module 2).",
        "2) Preview anomalies (Module 3) pour créer ID_CONTRAT_CANON.",
        "3) Retour4C doit contenir au moins 1 ID parmi: SG_CONTRACT_ID, SG_CONTR_BCE, SG_CONTR_3D_ID, SG_FACILITY_ID, SG_ID_ENREGISTRMNT",
        sep = "\n- "
      ),
      expr = {
        dt <- copy(ret_prep())
        a  <- copy(ano_dt())

        id_cols <- c("SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT")
        present <- intersect(id_cols, names(dt))
        if (length(present) == 0) stop("Aucune colonne ID connue n'est présente dans Retour4C.")

        task_mod3(modifyList(task_mod3(), list(last_msg = paste0("Colonnes ID testées: ", paste(present, collapse=", "), " ..."))))
        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")
          if (!canon_name %in% names(dt)) dt[, (canon_name) := canon_id(get(cn))]
        }

        ids <- unique(na.omit(a$ID_CONTRAT_CANON))
        if (length(ids) == 0) stop("Aucun ID_CONTRAT exploitable dans anomalies.")

        matches <- list()
        for (cn in present) {
          canon_name <- paste0(cn, "_CANON")
          aj <- data.table(ID_CONTRAT_CANON = ids)
          setnames(aj, "ID_CONTRAT_CANON", canon_name)

          setkeyv(dt, canon_name)
          setkeyv(aj, canon_name)

          m <- dt[aj, nomatch = 0]
          if (nrow(m) > 0) {
            m[, MATCHED_ON := cn]
            matches[[cn]] <- m
          }
        }

        if (length(matches) == 0) {
          diag_txt("0 match. Vérifier : scientific Excel, zéros initiaux, espaces, et la bonne colonne ID dans Retour4C.")
          extract_dt(data.table())
          return(data.table())
        }

        out <- rbindlist(matches, fill = TRUE)
        out <- unique(out, by = "OBS_ID")

        if (!"ID_CONTRAT_CANON" %in% names(out)) {
          out[, ID_CONTRAT_CANON := NA_character_]
          for (cn in present) {
            ccn <- paste0(cn, "_CANON")
            out[is.na(ID_CONTRAT_CANON) & !is.na(get(ccn)), ID_CONTRAT_CANON := get(ccn)]
          }
        }

        keep <- intersect(c(
          "GoldenSource",
          "ID_CONTRAT_CANON", "ASOF_DT","ASOF","PRTF","SSPRTF","Segment","PRODUCT_ID",
          "Encours","EAD","RWA","EAD_B","EAD_HB","CCF","RW","PD","LGD","M",
          "MATCHED_ON","OBS_ID",
          "SG_CONTRACT_ID","SG_CONTR_BCE","SG_CONTR_3D_ID","SG_FACILITY_ID","SG_ID_ENREGISTRMNT"
        ), names(out))
        out <- out[, ..keep]

        extract_dt(out)
        diag_txt(paste0("Matches: ", nrow(out), " | IDs testées: ", paste(present, collapse=", ")))
        out
      },
      success_msg = "Extraction terminée. Voir 'Résultat extraction' + 'Diagnostic'."
    )
  })

  output$ano_extract <- renderDT({
    dt <- extract_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })
  output$ano_diag <- renderPrint({ cat(diag_txt()) })

  output$dl_extract <- downloadHandler(
    filename = function() paste0("ead_rwa_ano_dq_", Sys.Date(), ".xlsx"),
    content = function(file) {
      wb <- createWorkbook()
      addWorksheet(wb, "extraction")
      writeDataTable(wb, "extraction", extract_dt())
      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )

  # ============================================================
  # MODULE 4 - Recalcul RWA (DQ optionnel) + synthèses + tops
  # ============================================================
  observeEvent(input$btn_recalc, {
    req(ano_dt()); req(ret_prep())

    run_task(
      task_mod4, err_mod4_rv,
      action_label = "Module 4 / Recalcul & comparaison",
      prereq_text = paste(
        "1) Module 3 -> Extraction (matches > 0).",
        "2) anomalies: ID_CONTRAT présent.",
        "3) Toute colonne *_corrige est optionnelle.",
        "4) Si RW absent: fournir RW_corrige, ou RW en base, ou RWA/EAD possible, ou activer la grille RW interne.",
        sep = "\n- "
      ),
      expr = {
        ex <- extract_dt()
        if (is.null(ex) || nrow(ex) == 0) stop("Aucune extraction disponible. Lancer Module 3 -> Extraction d'abord.")
        a <- copy(ano_dt())
        if (!"ID_CONTRAT_CANON" %in% names(a)) stop("ID_CONTRAT_CANON absent. Relancer Module 3 -> Preview anomalies.")

        task_mod4(modifyList(task_mod4(), list(last_msg = "Jointure anomalies ↔ extraction...")))
        setkey(a, ID_CONTRAT_CANON)
        setkey(ex, ID_CONTRAT_CANON)
        x <- a[ex]

        # corrections présentes par ligne
        corr_cols <- grep("_corrige$", names(x), value = TRUE)
        x[, corrections_appliquees := ""]
        if (length(corr_cols) > 0) {
          x[, corrections_appliquees := {
            filled <- corr_cols[sapply(.SD, function(v) any(!is.na(v) & trimws(as.character(v)) != ""))]
            paste(filled, collapse=";")
          }, .SDcols = corr_cols, by = .I]
        }

        # snapshot avant correction (audit)
        for (cn in c("PRTF","SSPRTF","Segment","EAD","CCF","RW","RWA")) {
          if (cn %in% names(x)) x[, paste0(cn,"_0") := get(cn)]
        }

        task_mod4(modifyList(task_mod4(), list(last_msg = "Application générique des *_corrige (optionnels)...")))
        x <- apply_corrige_generic(x)

        # EAD effectif
        x[, CCF := fifelse(!is.na(CCF), CCF, 1)]
        x[, EAD_eff := {
          if (!all(is.na(EAD_B)) || !all(is.na(EAD_HB))) {
            ead_b  <- fifelse(!is.na(EAD_B), EAD_B, 0)
            ead_hb <- fifelse(!is.na(EAD_HB), EAD_HB, 0)
            ead_b + (ead_hb * CCF)
          } else {
            EAD
          }
        }]

        # Surete
        surete_val <- NULL
        if ("Surete_corrige" %in% names(x)) surete_val <- suppressWarnings(as.integer(x$Surete_corrige))
        else if ("Surete" %in% names(x))    surete_val <- suppressWarnings(as.integer(x$Surete))
        else surete_val <- rep(0L, nrow(x))
        surete_val[is.na(surete_val)] <- 0L
        x[, Surete_used := surete_val]

        hc <- input$recalc_haircut/100
        x[, EAD_adj := fifelse(Surete_used == 1L, EAD_eff * (1 - hc), EAD_eff)]

        # RW cascade
        x[, RW_raw := RW]
        x[, RW_ratio := { rw <- to_num_safe(RW_raw); fifelse(!is.na(rw) & rw > 2, rw/100, rw) }]
        x[, RW_from_retour4c := fifelse(!is.na(RWA) & !is.na(EAD_eff) & EAD_eff > 0, RWA / EAD_eff, NA_real_)]

        rw_corr_ratio <- rep(NA_real_, nrow(x))
        if ("RW_corrige" %in% names(x)) {
          tmp <- to_num_safe(x$RW_corrige)
          rw_corr_ratio <- ifelse(!is.na(tmp) & tmp > 2, tmp/100, tmp)
        }

        default_flag <- rep(0L, nrow(x))
        if ("Default_corrige" %in% names(x)) default_flag <- suppressWarnings(as.integer(x$Default_corrige))
        else if ("Default" %in% names(x))    default_flag <- suppressWarnings(as.integer(x$Default))
        default_flag[is.na(default_flag)] <- 0L
        x[, Default_used := default_flag]

        x[, RW_used := {
          if (!is.na(rw_corr_ratio)) {
            rw_corr_ratio
          } else if (!is.na(RW_ratio)) {
            RW_ratio
          } else if (!is.na(RW_from_retour4c)) {
            RW_from_retour4c
          } else if (isTRUE(input$use_rw_lookup)) {
            mapply(rw_sa_lookup, PRTF, SSPRTF, Segment, Default_used)
          } else {
            NA_real_
          }
        }]

        task_mod4(modifyList(task_mod4(), list(last_msg = "Recalcul RWA + comparaison...")))
        if (input$recalc_meth == "standard") {
          x[, RWA_calc_corrige := EAD_adj * RW_used]
        } else {
          pd <- if ("PD_corrige" %in% names(x)) to_num_safe(x$PD_corrige)/100 else to_num_safe(x$PD)/100
          lgd<- if ("LGD_corrige" %in% names(x)) to_num_safe(x$LGD_corrige)/100 else to_num_safe(x$LGD)/100
          sc <- if ("IRB_scaling" %in% names(x)) to_num_safe(x$IRB_scaling) else 1.0
          x[, K := pd * lgd]
          x[, RWA_calc_corrige := 12.5 * K * EAD_adj * sc]
        }

        x[, RWA_retour4c := RWA]
        x[, Delta_RWA := RWA_calc_corrige - RWA_retour4c]
        x[, calc_flag := fifelse(is.na(RWA_calc_corrige), "KO", "OK")]
        x[is.na(RWA_calc_corrige) & is.na(RW_used) & input$recalc_meth=="standard",
          calc_msg := "RW_used indisponible: fournir RW_corrige, ou RW en base, ou RWA/EAD possible, ou activer la grille RW interne."]
        x[is.na(RWA_calc_corrige) & input$recalc_meth=="irba",
          calc_msg := "IRBA proxy: PD/LGD absents ou non numériques. Fournir PD_corrige/LGD_corrige ou champs PD/LGD en base."]

        keep <- intersect(c(
          "GoldenSource",
          "ID_CONTRAT","ID_CONTRAT_CANON","MATCHED_ON","OBS_ID",
          "ASOF_DT","PRTF","SSPRTF","Segment","PRODUCT_ID",
          "Encours","EAD","EAD_B","EAD_HB","CCF","EAD_eff","EAD_adj",
          "RW","RW_ratio","RW_from_retour4c","RW_used",
          "Surete_used","Default_used",
          "RWA_retour4c","RWA_calc_corrige","Delta_RWA",
          "corrections_appliquees","calc_flag","calc_msg",
          "PRTF_0","SSPRTF_0","Segment_0","EAD_0","CCF_0","RW_0","RWA_0"
        ), names(x))
        x_out <- x[, ..keep]

        task_mod4(modifyList(task_mod4(), list(last_msg = "Synthèses + stats corrections + Top 50...")))
        syn <- compute_recalc_summaries(x_out)
        recalc_syn_prtf_rv(syn$syn_prtf)
        recalc_syn_gs_rv(syn$syn_gs)
        corr_stats_rv(compute_corr_stats(ano_dt()))
        recalc_dt(x_out)
        recalc_ts(Sys.time())

        tops <- compute_tops(x_out)
        tops_abs(tops$top50_abs)
        tops_pos(tops$top50_pos)
        tops_neg(tops$top50_neg)
        tops_rwa(tops$top50_rwa)

        x_out
      },
      success_msg = "Recalcul terminé. Synthèses/Top50 générés. Export disponible."
    )
  })

  output$recalc_tbl <- renderDT({
    dt <- recalc_dt()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable(dt, options = list(scrollX = TRUE, pageLength = 10))
  })

  output$recalc_syn_note <- renderUI({
    if (is.null(recalc_ts())) return(div(class="small-note","Aucun recalcul effectué."))
    div(class="small-note", paste0("Dernier recalcul: ", format(recalc_ts(), "%Y-%m-%d %H:%M:%S")))
  })
  output$recalc_syn_prtf <- renderDT({
    dt <- recalc_syn_prtf_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable_fr(dt, digits_cols = c("RWA_Retour4C_MEUR","RWA_Corrige_MEUR","Delta_RWA_MEUR"))
  })
  output$recalc_syn_gs <- renderDT({
    dt <- recalc_syn_gs_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable_fr(dt, digits_cols = c("RWA_Retour4C_MEUR","RWA_Corrige_MEUR","Delta_RWA_MEUR"))
  })

  output$corr_note <- renderUI({
    if (is.null(corr_stats_rv())) return(div(class="small-note","Charger anomalies puis lancer un recalcul pour produire les stats."))
    div(class="small-note","Statistiques de remplissage des colonnes *_corrige dans anomalies_dq.xlsx.")
  })
  output$corr_stats_tbl <- renderDT({
    dt <- corr_stats_rv()
    if (is.null(dt)) return(datatable(data.frame()))
    datatable_fr(dt, digits_cols = c("pct_remplissage"))
  })

  # ---------- TOP 50 UI
  output$top_note <- renderUI({
    if (is.null(tops_abs())) return(div(class="small-note","Aucun Top50. Lancer le recalcul (Module 4)."))
    div(class="small-note","Top50 calculés. Graphes en MEUR (plus lisible).")
  })

  # ---------- TOP 50 tables
  output$top50_abs_tbl <- renderDT({ tt <- tops_abs(); if (is.null(tt)) datatable(data.frame()) else datatable(tt, options=list(scrollX=TRUE, pageLength=10)) })
  output$top50_pos_tbl <- renderDT({ tt <- tops_pos(); if (is.null(tt)) datatable(data.frame()) else datatable(tt, options=list(scrollX=TRUE, pageLength=10)) })
  output$top50_neg_tbl <- renderDT({ tt <- tops_neg(); if (is.null(tt)) datatable(data.frame()) else datatable(tt, options=list(scrollX=TRUE, pageLength=10)) })
  output$top50_rwa_tbl <- renderDT({ tt <- tops_rwa(); if (is.null(tt)) datatable(data.frame()) else datatable(tt, options=list(scrollX=TRUE, pageLength=10)) })

  # ---------- TOP 50 plots
  plot_top <- function(tt, y_col, y_lab) {
    req(tt)
    d <- copy(tt)
    if (!y_col %in% names(d)) return(NULL)
    d[, y := get(y_col)/1e6]
    d[, id_bar := if ("ID_CONTRAT" %in% names(d)) ID_CONTRAT else ID_CONTRAT_CANON]
    d <- d[!is.na(y)]
    if (nrow(d) == 0) return(NULL)

    ggplot(d, aes(x = reorder(id_bar, y), y = y)) +
      geom_col() +
      coord_flip() +
      theme_minimal() +
      labs(x = "ID_CONTRAT", y = y_lab)
  }

  output$top50_abs_plot <- renderPlot({ plot_top(tops_abs(), "Delta_RWA", "ΔRWA (MEUR)") })
  output$top50_pos_plot <- renderPlot({ plot_top(tops_pos(), "Delta_RWA", "ΔRWA positif (MEUR)") })
  output$top50_neg_plot <- renderPlot({ plot_top(tops_neg(), "Delta_RWA", "ΔRWA négatif (MEUR)") })
  output$top50_rwa_plot <- renderPlot({ plot_top(tops_rwa(), "RWA_calc_corrige", "RWA corrigé (MEUR)") })

  # ---------- Export recalcul (multi-onglets + tops)
  output$dl_recalc <- downloadHandler(
    filename = function() paste0("rwa_recalc_compare_", Sys.Date(), ".xlsx"),
    content = function(file) {
      wb <- createWorkbook()

      addWorksheet(wb, "detail");            writeDataTable(wb, "detail", recalc_dt())
      addWorksheet(wb, "syn_prtf_ssprtf");   writeDataTable(wb, "syn_prtf_ssprtf", recalc_syn_prtf_rv())
      addWorksheet(wb, "syn_goldensource");  writeDataTable(wb, "syn_goldensource", recalc_syn_gs_rv())
      addWorksheet(wb, "corr_stats");        writeDataTable(wb, "corr_stats", corr_stats_rv())

      addWorksheet(wb, "top50_abs");         writeDataTable(wb, "top50_abs", tops_abs())
      addWorksheet(wb, "top50_pos");         writeDataTable(wb, "top50_pos", tops_pos())
      addWorksheet(wb, "top50_neg");         writeDataTable(wb, "top50_neg", tops_neg())
      addWorksheet(wb, "top50_rwa_corrige"); writeDataTable(wb, "top50_rwa_corrige", tops_rwa())

      saveWorkbook(wb, file, overwrite = TRUE)
    }
  )
}

shinyApp(ui, server)